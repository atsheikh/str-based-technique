#########################################################################################
# Description: 	This file generates Probability of failure of each gate					#
#			   	of a circuit using the fault simulations result 						#
#				generated by the HOPE fault simulator. 									#
#																						#
#				This program generates two files;										#
#					1):- .prop Propagation probability of each gate						#
#					2):- .ipp Input pattern probability of each gate					#
#																						#
# USAGE: perl gatePOFs benchFile [without .bench extension]								#
# 																						#
# Author: Ahmad Tariq Sheikh.															#
#																						#
# Date: October 31, 2014																#
#																						#
#########################################################################################

#!/usr/bin/perl -w

use warnings;
use Cwd;
use Time::HiRes;
use File::Basename;
use Data::Dumper qw(Dumper);
use Storable qw(retrieve nstore);
#---------------------

sub intersect(\@\@) {
	my %e = map { $_ => undef } @{$_[0]};
	return grep { exists( $e{$_} ) } @{$_[1]};
}

sub readBenchFile {
	print "\tReading $newBenchFile file ... \n";
	my $start_time = [Time::HiRes::gettimeofday()];
	
	open (INPUT_FILE, $newBenchFile) or die $!;
	
	my %tempCompleteGates = ();	
	
	while(<INPUT_FILE>) {
		if ($_ =~ m/INPUT(.*)/) {		
			if ($1 =~ m/(\w+)/) {
				push (@inputGates, $1);	
			}
		}
		elsif ($_ =~ m/OUTPUT(.*)/) {
			if ($1 =~ m/(\w+)/) {
				push (@outputGates, $1);	
			}
		}
		elsif ($_ =~ /#/ or $_ =~ /^\s/) {
			next;
		}		
		elsif ($_ =~ m/=/) {			
			my @gateList = ($_ =~ m/(\w+)/g);				
			$gateName[0] = $gateList[1];			
			@gateList = ($gateList[0], @gateList[2..$#gateList]);		
					
			#---------------------------------------------------
			# Create an output to input and input to output MAP
			#---------------------------------------------------
			my $connections;
			for my $i (1..scalar @gateList-1) {				
				$connections .= "$gateList[$i]";	
				if ((scalar @gateList > 1) && ($i < scalar @gateList-1)) {
					$connections .= "-";
				}
				
				if (exists($input2Output{$gateList[$i]})) {				
					$temp = $input2Output{$gateList[$i]};
					$input2Output{$gateList[$i]} = $temp."-".$gateList[0];
				}
				else {
					$input2Output{$gateList[$i]} = $gateList[0];	
				}				
			}
			$Output2Input{$gateList[0]} = $gateName[0]."-".$connections;				
			
			push @inter_IO_Gates, $gateList[0];				
			#-------------------------------------------------
			
			for my $i(0..scalar @gateList - 1) {			
				if (!(exists($tempCompleteGates{$gateList[$i]}))) {				
					if ($i == 0) {					
						$tempCompleteGates{$gateList[$i]} = 0;	
						$gatesCounter{$gateList[$i]} = 0;
						$completeGates{$gateList[$i]} = 0;	
					}
					else {					
						$tempCompleteGates{$gateList[$i]} = $gateList[0];	
						$gatesCounter{$gateList[$i]} = 1;
						$completeGates{$gateList[$i]} = "$gateName[0]-$gateList[0]";	
					}
				}
				else {				
					$gatesCounter{$gateList[$i]}++;										
					if ($gatesCounter{$gateList[$i]} >= 2) {							
						$tempCompleteGates{"$gateList[$i]->$gateList[0]"} = $gateList[0];
						$tempCompleteGates{"$gateList[$i]->$tempCompleteGates{$gateList[$i]}"} = $tempCompleteGates{$gateList[$i]};												
						$gatesCounter{"$gateList[$i]->$gateList[0]"} = 0;
						$gatesCounter{"$gateList[$i]->$tempCompleteGates{$gateList[$i]}"} = 0;						
						
						if ($completeGates{$gateList[$i]} eq 0) {
							$completeGates{"$gateList[$i]->$gateList[0]"} = "$gateName[0]-$gateList[0]";	
						}
						else {
							$completeGates{"$gateList[$i]->$gateList[0]"} = "$gateName[0]-$gateList[0]";						
							@previousLine = split('-', $completeGates{$gateList[$i]});							
							$completeGates{"$gateList[$i]->$previousLine[1]"} = "$previousLine[0]-$previousLine[1]";					
							$completeGates{$gateList[$i]} = 0;
						}
					}
					else {	
						$tempCompleteGates{$gateList[$i]} = $gateList[0];							
						$completeGates{$gateList[$i]} = "$gateName[0]-$gateList[0]";													
					}
				}
			}					
		}		
	}	
	close(INPUT_FILE);	
	my $run_time = Time::HiRes::tv_interval($start_time);
	print "\tTime taken Reading Bench file = $run_time sec.\n\n";	
	
	@inter_IO_Gates = reverse(@inter_IO_Gates);		
}
#######################################################

sub createBenchFileWithAllNetsAsOutputs {
	print "\tReading $newBenchFile file ... \n";
	my $start_time = [Time::HiRes::gettimeofday()];
	
	@inter_IO_Gates = reverse(@inter_IO_Gates);	
	
	open (OUT_FILE, ">$newFile") or die $!;
	
	open (INPUT_FILE, $newBenchFile) or die $!;
	
	print OUT_FILE "\n";
	
	foreach $k (0..scalar @inputGates - 1) {
		print OUT_FILE "INPUT($inputGates[$k])\n";
	}
	print OUT_FILE "\n";
	foreach $k (0..scalar @outputGates - 1) {
		print OUT_FILE "OUTPUT($outputGates[$k])\n";
	}
	print OUT_FILE "\n";
	foreach $k (0..scalar @inter_IO_Gates - 1) {
		$internalGates{$inter_IO_Gates[$k]} = 0; #initialize the internal gate output values
		if (grep {$_ eq $inter_IO_Gates[$k]} @outputGates) {
			next;
		}
		else { #only print the internal gate outputs			
			print OUT_FILE "OUTPUT($inter_IO_Gates[$k])\n";			
		}
	}
	print OUT_FILE "\n";
	
	while(<INPUT_FILE>) {		
		if ($_ =~ m/=/) {
			print OUT_FILE $_;
		}			
	}	
	print OUT_FILE "\nEND";
	
	close(INPUT_FILE);		
	close(OUT_FILE);	
	
	system("dos2unix $newFile"); 
	
	my $run_time = Time::HiRes::tv_interval($start_time);
	
	print "\tTime taken Reading Bench file = $run_time sec.\n\n";		
}
#######################################################

sub computeStatisticsFromFaultFile {		
	
	$file = $inputFile."-FO.fault";
	
	print "\tReading $file file ... \n";
	my $start_time = [Time::HiRes::gettimeofday()];
	
	open (FILE, "$file") or die $!;		

	while (<FILE>) {
		chomp;
		if ($_ =~ m/\*/) {	
			$flag = 1;
			next;			
		}
		elsif($_ =~ m/Number of primary inputs(.*)/) {
			if ($1 =~ m/(\d+)/) 	{
				$numberOfPrimaryInputs = $1;
			}			
		}
		elsif($_ =~ m/Number of primary outputs(.*)/) {
			if ($1 =~ m/(\d+)/) 	{
				$numberOfPrimaryOutputs = $1;
			}			
		}
		elsif($_ =~ m/Number of combinational gates(.*)/) {
			if ($1 =~ m/(\d+)/) 	{
				$numberOfCombGates = $1;
			}			
		}
		elsif($_ =~ m/Number of flip-flops(.*)/) {
			if ($1 =~ m/(\d+)/) 	{
				$numberOfFF = $1;
			}			
		}
		elsif($_ =~ m/Level of the circuit(.*)/) {
			if ($1 =~ m/(\d+)/) 	{
				$numberOfLevels = $1;
			}			
		}
		elsif($_ =~ m/Number of test patterns applied(.*)/) {
			if ($1 =~ m/(\d+)/) 	{
				$numberOfTestVectors = $1;
			}			
		}
		elsif($_ =~ m/Number of collapsed faults(.*)/) {
			if ($1 =~ m/(\d+)/) 	{
				$numberOfCollapsedFaults = $1;
			}			
		}
		elsif($_ =~ m/Number of detected faults(.*)/) {
			if ($1 =~ m/(\d+)/) {
				$numberOfDetectedFaults = $1;
			}			
		}
		elsif($_ =~ m/Number of undetected faults(.*)/) {
			if ($1 =~ m/(\d+)/) {
				$numberOfUndetectedFaults = $1;				
			}			
		}
		elsif($_ =~ m/Fault coverage(.*)/) {
			if ($1 =~ m/(\d+\.\d+)/) {
				$faultCoverage = $1;
			}			
		}
		elsif (!$flag) {
			$row = [ split ];
			if (@$row[0] =~ m/test/) {					
				@currentInput =  split('', @$row[2]);
				@currentOutput = split('', @$row[3]);	

				# print "CI = @currentInput\nCO = @currentOutput \n"; 
				
				################################################################################
				#Assign PO their respective values
				my $index = 0;
				foreach $value(@outputGates) {
					$internalGates{$value} = $currentOutput[$index];
					$index++;
				}
								
				#Assign each intermediate output it's value from the @currentOutput vector						
				foreach $value (@inter_IO_Gates) {
					if (grep {$_ eq $value} @outputGates) {
						next;
					}
					else {
						$internalGates{$value} = $currentOutput[$index];
						$index++;
					}
				}			
				
				#Assign PI their respective values
				$index=0;
				foreach $value(@inputGates) {
					$internalGates{$value} = $currentInput[$index];
					$index++;
				}
				# print Dumper \%internalGates;			
				
				################################################################################
												
				# For each gate process store and count its input pattern
				foreach $currentGate (@inter_IO_Gates) {
					@inputsToCurrentGate = split('-',$Output2Input{$currentGate});
					
					# print "CG = $currentGate, Inputs = @inputsToCurrentGate, @inputGates\n"; $cin=getc(STDIN);
					
					#Remove GATE NAME from the TOP
					shift(@inputsToCurrentGate);
										
					#Assemble each input into a vector
					$currentVector = ();
					foreach $input (@inputsToCurrentGate) {
						$currentVector .= $internalGates{$input}; 
					}										
					$gateStatistics{$currentGate}{$currentVector} += 1;					
				}	
				# print Dumper \%gateStatistics; $cin=getc(STDIN);	
				
			}#end of output vectors evaluation
		} #end of last elsif on line 232		
	}#end of while input loop
	close(FILE);			
		
	#Average the gate statistics
	for $gate ( keys %gateStatistics ) {		
		for $vector ( keys %{ $gateStatistics{$gate} } ) {			
			$gateStatistics_averaged{$gate}{$vector} = $gateStatistics{$gate}{$vector}/($numberOfTestVectors);    
		}
    }		
	
	my $run_time = Time::HiRes::tv_interval($start_time);
	print  "\tTime taken Reading Faults file = $run_time sec.\n\n";		
}
#######################################################

sub computePropProbs {

	print "---Computing the Controllability of each gate of circuit...\n";
	
	my $start_time = [Time::HiRes::gettimeofday()];
	$file = $inputFile.".prop";
	
	# $gateCont_N = 0; # nmos Gate controllability
	# $gateCont_P = 0; # pmos Gate controllability
	
	open(STATS_FILE, ">$file") or die $!;	
	
	#	Iterate through every gate and compute the vectors
	#	that will cause the fault to propagate.
	foreach $currentGate (@inter_IO_Gates) {
		@inputsToCurrentGate = split('-',$Output2Input{$currentGate});
		$currentGateType = shift(@inputsToCurrentGate);				
		
		# $currentGateArea = (scalar @inputsToCurrentGate)*$nmosDrainArea + (scalar @inputsToCurrentGate)*$pmosDrainArea;
		# print "CG = $currentGate, CT = $currentGateType\n"; $cin=getc(STDIN);
		
		# Process the NOT gates
		if ($currentGateType eq "NOT"){		
			if (exists($gateStatistics_averaged{$currentGate}{0})) {
				$freq_0 = $gateStatistics_averaged{$currentGate}{0};
			}
			else {
				$gateStatistics_averaged{$currentGate}{0} = 0;
				$freq_0 = $gateStatistics_averaged{$currentGate}{0};
			}
			
			if (exists($gateStatistics_averaged{$currentGate}{1})) {
				$freq_1 = $gateStatistics_averaged{$currentGate}{1};
			}
			else {
				$gateStatistics_averaged{$currentGate}{1} = 0;
				$freq_1 = $gateStatistics_averaged{$currentGate}{1};
			}
			
			# if ($currentGate eq "g8063_n227") { print "F = $freq_1\n"; }
			print STATS_FILE "$currentGate"."-N1=>$freq_0\n";
			print STATS_FILE "$currentGate"."-P1=>$freq_1\n";
		}
		
		# Process the NAND and NOR gates
		else {		
			# Process each input of a gate
			foreach $i (1..scalar @inputsToCurrentGate) {
				$nmos = $currentGateType.(scalar @inputsToCurrentGate)."-N".$i;
				$pmos = $currentGateType.(scalar @inputsToCurrentGate)."-P".$i;
				
				my @originalFailedVectors = ();
				my @currentFailedVectors = ();
				
				###################################################################
				#	Process the nmos of current gate
				###################################################################
				# Read the generic failed vectors for N-Type
				for $vector ( keys %{ $propProbs_130nm{$nmos} } ) {
						push @originalFailedVectors, $vector;								
				}
				
				# Read the failed vectors for current gate in the current circuit
				for $vector ( keys %{ $gateStatistics_averaged{$currentGate} } ) {
						push @currentFailedVectors, $vector;						
				}
				
				my @isect = intersect(@originalFailedVectors, @currentFailedVectors);
				
				# if ($currentGate eq "g783") {
					# print "Nmos = $nmos\n";
					# print "OFV_N = @originalFailedVectors\n";
					# print "CFV = @currentFailedVectors\n";
					# print "Common_N = @isect\n\n";
				# }
				
				$freq = 0;
				foreach $value (@isect) {
					$freq += $gateStatistics_averaged{$currentGate}{$value}; 
				}
				
				# if ($i==1) {
					# $gateCont_N = $freq;
				# }
				# $freq = $freq*($nmosDrainArea/$currentGateArea);
				# print STATS_FILE "$currentGate"."-N".$i."=>",$freq/$gateCont_N,"\n";
				print STATS_FILE "$currentGate"."-N".$i."=>$freq\n";
				
				###################################################################
				#	Process the pmos of current gate
				###################################################################
				# Read the generic failed vectors for P-Type
				@originalFailedVectors = ();
				for $vector ( keys %{ $propProbs_130nm{$pmos} } ) {
						push @originalFailedVectors, $vector;						
				}
				
				@isect = intersect(@originalFailedVectors, @currentFailedVectors);
				
				# if ($currentGate eq "g783") {
					# print "Pmos = $pmos\n";
					# print "OFV_P = @originalFailedVectors\n";
					# print "CFV = @currentFailedVectors\n";
					# print "Common_P = @isect\n\n";
				# }
				
				$freq = 0;
				foreach $value (@isect) {
					$freq += $gateStatistics_averaged{$currentGate}{$value}; 
				}
				
				# if ($i==1) {
					# $gateCont_P = $freq;
				# }				
				# $freq = $freq*($pmosDrainArea/$currentGateArea);
				# print STATS_FILE "$currentGate"."-P".$i."=>",$freq/$gateCont_P,"\n";				
				print STATS_FILE "$currentGate"."-P".$i."=>$freq\n";				
			}			
		}
	}		
	close (STATS_FILE);
	
	my $run_time = Time::HiRes::tv_interval($start_time);
	print  "\tTime taken computing FINAL FILE = $run_time sec.\n\n";	
}
#######################################################

#######################################################

#-----------------------------------------------
#		Main Program
#-----------------------------------------------

$cwd = getcwd; #get Current Working Directory
$inputFile = $ARGV[0]; #input bench file

#Read general probability of failures file for 45nm
# %propProbs_45nm = %{retrieve('45nm.pf')};
%propProbs_130nm = %{retrieve('130nm.pf')};

$newFile = $inputFile."-FO.bench";
$newBenchFile = $inputFile.".bench";


#-----------------------------------------------
#		Variables Initialization
#-----------------------------------------------
$numberOfPrimaryInputs = 0;
$numberOfPrimaryOutputs = 0;
$numberOfCombGates = 0;
$numberOfFF = 0;
$numberOfLevels = 0;
$numberOfCollapsedFaults = 0;
$numberOfDetectedFaults = 0;
$numberOfUndetectedFaults = 0;
$numberOfTestVectors  = 0;
$faultCoverage = 0;

@outputGates = ();
@inputGates = ();
@inter_IO_Gates = ();

%completeGates = ();
%Output2Input = ();
%input2Output = ();
%gatesCounter = ();

####################################################################################################
# Variables used to store and process gate input statistics
# $nmosDrainArea = 0.09;
# $pmosDrainArea = 0.18;
%internalGates = ();

# A hash of hash structure to store count of each input pattern for every gate.
# $iFile = fileparse($inputFile, "_MAJ");
%gateStatistics = (); 
%gateStatistics_averaged = ();
# %gateStatistics_averaged = %{retrieve($iFile.'.ipp')};
####################################################################################################

##############################################################
#	Step 1: Create Bench file with all gate outputs declared
#	as primary outputs POs.
readBenchFile();
createBenchFileWithAllNetsAsOutputs();
##############################################################

##############################################################
# 	Step 2: Compute input vector statistics of each gate in
#	the current circuit.
computeStatisticsFromFaultFile();
##############################################################

##############################################################
#	Step 3: Compute final statistics w.r.t to each transistor
#	of a gate in current circuit.
computePropProbs();
##############################################################

nstore \%gateStatistics_averaged, $inputFile.'.ipp';
print "TEST PATTERNS: $numberOfTestVectors\n";

# print Dumper \%gateStatistics_averaged;
# print Dumper \%propProbs_45nm;
system("del $inputFile-FO.bench");








