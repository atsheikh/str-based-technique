#########################################################################################
# Description: 	This file generates fault statistics from the faults					#
#			   	file generated by HOPE for a given benchmark. The						#
#				output is a new bench file consisting of Quaded and Duplicated logic	#
#																						#
# USAGE: perl circuit-stats.pl [Faults File] [Error Threshold]							#
#		[Faults File] = log file generated by HOPE.										#
#		[Error Threshold] =  reports only errors >= Threshold.							#
# 																						#
# Author: Ahmad Tariq Sheikh.															#
#																						#
# Date: October 26, 2013																#
#																						#
#########################################################################################

#!/usr/bin/perl -w

no warnings;
use Cwd;
use Time::HiRes;
use File::Basename;
use Data::Dumper qw(Dumper); 
use Storable qw(retrieve nstore dclone);
use Clone qw(clone);
use Sort::Naturally;
#---------------------

sub GetMaximumGainKey (\%) {
    my $hash = shift;
    keys %$hash;       # reset the each iterator

    my ($small_key, $small_val) = each %$hash;

    while (my ($key, $val) = each %$hash) {
        if ($val < $small_val) {
            $small_val = $val;
            $small_key = $key;
        }
    }
    return $small_key;
}
######################################################

sub intersect(\@\@) {
	my %e = map { $_ => undef } @{$_[0]};
	return grep { exists( $e{$_} ) } @{$_[1]};
}
#######################################################

sub difference(\@\@) {
	my %e = map{ $_ => undef } @{$_[1]};
	return grep( ! exists( $e{$_} ), @{$_[0]} ); 
}
#######################################################

sub getProtectionTypeNAND_NORMAL {
	my $cprot = $_[0];	
	my $cType = $_[1];
	my $inputs = $_[2];
	
	$protType = 0;	
	
	################################################################
	# STATE MACHINE TO DECIDE THE  SELECTION TYPE BASED ON CURRENT
	# PROTECTION TYPE AND THE GATE TYPE.
	################################################################
	
	if ($inputs == 2) {
		if ($cprot==0 and $cType =~ m/N/) {
			$protType = 1;
		}
		elsif (($cprot==1 or $cprot==2) and $cType =~ m/N/) {
			$protType = 2;
		}
		elsif (($cprot==0 or $cprot==3) and $cType =~ m/P/) {
			$protType = 3;
		}
		elsif (($cprot==3 and $cType =~ m/N/) or (($cprot==1 or $cprot==4) and $cType =~ m/P/)) {
			$protType = 4;
		}		
		elsif(($cprot==2 and $cType =~ m/P/) or ($cprot==4 and $cType =~ m/N/)) {
			$protType = 20;
		}		
		elsif($cprot==20) {
			$protType = 20;
		}
	}
	elsif ($inputs == 3) {
		if ($cprot==0 and $cType =~ m/N/) {
			$protType = 1;
		}
		elsif ($cprot==1 and $cType =~ m/N/) {
			$protType = 2;
		}
		elsif (($cprot==2 or $cprot==3) and $cType =~ m/N/) {
			$protType = 3;
		}		
		elsif (($cprot==0  or $cprot==4) and $cType =~ m/P/)  {
			$protType = 4;
		}
		elsif (($cprot==4 and $cType =~ m/N/) or ($cprot==1 and $cType =~ m/P/)) {
			$protType = 5;
		}
		elsif (($cprot==5 and $cType =~ m/N/) or ($cprot==2 and $cType =~ m/P/)) {
			$protType = 6;
		}			
		elsif (($cprot==6 and $cType =~ m/N/) or ($cprot==3 and $cType =~ m/P/)) {
			$protType = 20;
		}		
		elsif($cprot==20) {
			$protType = 20;
		}
	}
	elsif ($inputs == 4) {
		if ($cprot==0 and $cType =~ m/N/) {
			$protType = 1;
		}
		elsif ($cprot==1 and $cType =~ m/N/) {
			$protType = 2;
		}
		elsif ($cprot==2 and $cType =~ m/N/) {
			$protType = 3;
		}		
		elsif (($cprot==3 or $cprot==4) and $cType =~ m/N/) {
			$protType = 4;
		}		
		elsif (($cprot==0 or $cprot==5) and $cType =~ m/P/)  {
			$protType = 5;
		}
		elsif (($cprot==5 and $cType =~ m/N/) or ($cprot==1 and $cType =~ m/P/)) {
			$protType = 6;
		}
		elsif (($cprot==6 and $cType =~ m/N/) or ($cprot==2 and $cType =~ m/P/)) {
			$protType = 7;
		}		
		elsif (($cprot==7 and $cType =~ m/N/ ) or ($cprot==3 and $cType =~ m/P/)) {
			$protType = 8;
		}		
		elsif(($cprot==8 and $cType =~ m/N/) or ($cprot==4 and $cType =~ m/P/)){
			$protType = 20;
		}		
		elsif($cprot==20) {
			$protType = 20;
		}
	}	
	# print "Cprot = $cprot, CTYPE = $cType, Inputs = $inputs, Prot Type = $protType\n"; #$cin = getc(STDIN);
	return $protType;
}
#######################################################

sub getProtectionTypeNOR_NORMAL {
	my $cprot = $_[0];	
	my $cType = $_[1];
	my $inputs = $_[2];
	
	$protType = 0;	
	
	################################################################
	# STATE MACHINE TO DECIDE THE  SELECTION TYPE BASED ON CURRENT
	# PROTECTION TYPE AND THE GATE TYPE.
	################################################################
	
	if ($inputs == 2) {
		if ($cprot==0 and $cType =~ m/P/) {
			$protType = 1;
		}
		elsif (($cprot==1 or $cprot==2) and $cType =~ m/P/) {
			$protType = 2;
		}
		elsif (($cprot==0 or $cprot==3) and $cType =~ m/N/) {
			$protType = 3;
		}
		elsif (($cprot==3 and $cType =~ m/P/) or (($cprot==1 or $cprot==4) and $cType =~ m/N/)) {
			$protType = 4;
		}		
		elsif(($cprot==2 and $cType =~ m/N/) or ($cprot==4 and $cType =~ m/P/)) {
			$protType = 20;
		}		
		elsif($cprot==20) {
			$protType = 20;
		}
	}
	elsif ($inputs == 3) {
		if ($cprot==0 and $cType =~ m/P/) {
			$protType = 1;
		}
		elsif ($cprot==1 and $cType =~ m/P/) {
			$protType = 2;
		}
		elsif (($cprot==2 or $cprot==3) and $cType =~ m/P/) {
			$protType = 3;
		}		
		elsif (($cprot==0  or $cprot==4) and $cType =~ m/N/)  {
			$protType = 4;
		}
		elsif (($cprot==4 and $cType =~ m/P/) or ($cprot==1 and $cType =~ m/N/)) {
			$protType = 5;
		}
		elsif (($cprot==5 and $cType =~ m/P/) or ($cprot==2 and $cType =~ m/N/)) {
			$protType = 6;
		}			
		elsif (($cprot==6 and $cType =~ m/P/) or ($cprot==3 and $cType =~ m/N/)) {
			$protType = 20;
		}		
		elsif($cprot==20) {
			$protType = 20;
		}
	}
	elsif ($inputs == 4) {
		if ($cprot==0 and $cType =~ m/P/) {
			$protType = 1;
		}
		elsif ($cprot==1 and $cType =~ m/P/) {
			$protType = 2;
		}
		elsif ($cprot==2 and $cType =~ m/P/) {
			$protType = 3;
		}		
		elsif (($cprot==3 or $cprot==4) and $cType =~ m/P/) {
			$protType = 4;
		}		
		elsif (($cprot==0 or $cprot==5) and $cType =~ m/N/)  {
			$protType = 5;
		}
		elsif (($cprot==5 and $cType =~ m/P/) or ($cprot==1 and $cType =~ m/N/)) {
			$protType = 6;
		}
		elsif (($cprot==6 and $cType =~ m/P/) or ($cprot==2 and $cType =~ m/N/)) {
			$protType = 7;
		}		
		elsif (($cprot==7 and $cType =~ m/P/ ) or ($cprot==3 and $cType =~ m/N/)) {
			$protType = 8;
		}		
		elsif(($cprot==8 and $cType =~ m/P/) or ($cprot==4 and $cType =~ m/N/)){
			$protType = 20;
		}		
		elsif($cprot==20) {
			$protType = 20;
		}
	}	
	
	# print "Cprot = $cprot, CTYPE = $cType, Inputs = $inputs, Prot Type = $protType\n"; #$cin = getc(STDIN);
	return $protType;
}
#######################################################

sub getProtectionTypeNOT {
	my $cprot = $_[0];	
	my $cType = $_[1];
	my $inputs = $_[2];
	
	$protType = 0;	
	
	################################################################
	# STATE MACHINE TO DECIDE THE  SELECTION TYPE BASED ON CURRENT
	# PROTECTION TYPE AND THE GATE TYPE.
	################################################################
	
	if (($cprot==0 or $cprot==1) and $cType =~ m/N1/) {
		$protType = 1;
	}
	elsif (($cprot==0 or $cprot==2) and $cType =~ /P/) {
		$protType = 2;
	}
	else {
		$protType = 20;
	}	
		
	return $protType;
}
#######################################################

sub getProtectionTypeNAND_Lazzari {
	my $cprot = $_[0];	
	my $cType = $_[1];
	my $inputs = $_[2];
	
	$protType = 0;	
	
	################################################################
	# STATE MACHINE TO DECIDE THE  SELECTION TYPE BASED ON CURRENT
	# PROTECTION TYPE AND THE GATE TYPE FOR LAZZARI PAPER.
	################################################################
	
	if ($cprot==0 and $cType eq "sa0") {
		$protType = 1;
	}
	elsif ($cprot==0 and $cType eq "sa1") {
		$protType = $inputs + 1;
	}
	elsif ($cprot==1 and $cType eq "sa1") {
		$protType = $inputs + 2;
	}
	elsif ( ($cprot==($inputs + 1)) and $cType eq "sa0") {
		$protType = $inputs + 2;
	}
	
	# print "Cprot = $cprot, CTYPE = $cType, Inputs = $inputs, Prot Type = $protType\n"; #$cin = getc(STDIN);
	return $protType;
}
#######################################################

sub getProtectionTypeNOR_Lazzari {
	my $cprot = $_[0];	
	my $cType = $_[1];
	my $inputs = $_[2];
	
	$protType = 0;	
	
	################################################################
	# STATE MACHINE TO DECIDE THE  SELECTION TYPE BASED ON CURRENT
	# PROTECTION TYPE AND THE GATE TYPE.
	################################################################
	
	if ($cprot==0 and $cType eq "sa1") {
		$protType = 1;
	}
	elsif ($cprot==0 and $cType eq "sa0") {
		$protType = $inputs + 1;
	}
	elsif ($cprot==1 and $cType eq "sa0") {
		$protType = $inputs + 2;
	}
	elsif ( ($cprot==($inputs + 1)) and $cType eq "sa1") {
		$protType = $inputs + 2;
	}
	
	# print "Cprot = $cprot, CTYPE = $cType, Inputs = $inputs, Prot Type = $protType\n"; #$cin = getc(STDIN);
	return $protType;
}
#######################################################

sub getProtectionTypeNOT_Lazzari {

	my $cprot = $_[0];	
	my $cType = $_[1];
	my $inputs = $_[2];
	
	$protType = 0;	
	
	################################################################
	# STATE MACHINE TO DECIDE THE  SELECTION TYPE BASED ON CURRENT
	# PROTECTION TYPE AND THE GATE TYPE.
	################################################################
	
	if ($cprot==0 and $cType eq "sa0") {
		$protType = 1;
	}
	elsif ($cprot==0 and $cType eq "sa1") {
		$protType = 2;
	}
	elsif ($cprot==1 and $cType eq "sa1") {
		$protType = 20;
	}	
	elsif ($cprot==2 and $cType eq "sa0") {
		$protType = 20;
	}	
		
	return $protType;
}
#######################################################

sub getProcessedNodes {
	my $currentNode = $_[0];
	my $gateName = $_[1];
	my $inputs = $_[2];
	
	@row = split("-", $currentNode);
	@row1 = ($row[1] =~ m/(\d+)/g);
	$counter = $row1[0];
	
	my @nodesProcessed = ();
	
	# print "NC: $currentNode, GN: $gateName, Counter: $counter, Ctype = $row[1], inputs = $inputs\n";
	if ($gateName eq "NAND" and $row[1] =~ m/N/) {
		for (my $i=$counter; $i >= 1; $i--) {
			push @nodesProcessed, $row[0]."-N$i";
		}		
	}
	elsif ($gateName eq "NAND" and $row[1] =~ m/P/) {
		for (my $i=1; $i <= $inputs; $i++) {
			push @nodesProcessed, $row[0]."-P$i";
		}		
	}
	elsif ($gateName eq "NOR" and $row[1] =~ m/P/) {
		for (my $i=$counter; $i >= 1; $i--) {
			push @nodesProcessed, $row[0]."-P$i";
		}		
	}
	elsif ($gateName eq "NOR" and $row[1] =~ m/N/) {
		for (my $i=1; $i <= $inputs; $i++) {
			push @nodesProcessed, $row[0]."-N$i";
		}		
	}
	elsif ($gateName eq "NOT" and $row[1] =~ m/N/) {
		push @nodesProcessed, $row[0]."-N1";
	}
	elsif ($gateName eq "NOT" and $row[1] =~ m/P/) {
		push @nodesProcessed, $row[0]."-P1";
	}
	
	# print "NP: @nodesProcessed\n";
	return @nodesProcessed;
}
#######################################################

sub getProtectionTypeNAND_OVER_PROTECTION {
	my $cprot = $_[0];	
	my $cType = $_[1];
	my $inputs = $_[2];
	
	$protType = 0;	
	
	################################################################
	# STATE MACHINE TO DECIDE THE  SELECTION TYPE BASED ON CURRENT
	# PROTECTION TYPE AND THE GATE TYPE.
	################################################################
	
	if ($inputs == 2) {
		if (($cprot==0 or $cprot==1) and $cType eq "N1") {
			$protType = 1;
		}
		elsif (($cprot==0 or $cprot==1) and $cType eq "N2") {
			$protType = 2;
		}
		elsif (($cprot==0 or $cprot==3) and $cType =~ m/P/) {
			$protType = 3;
		}
		elsif (($cprot==3 and $cType eq "N1") or ($cprot==1 and $cType =~ m/P/) or ($cprot==4)) {
			$protType = 4;
		}		
		elsif(($cprot==2 and $cType =~ m/P/) or ($cprot==3 and $cType eq "N2") or ($cprot==4 and $cType eq "N2")){
			$protType = 20;
		}		
		elsif($cprot==20) {
			$protType = 20;
		}
	}
	elsif ($inputs == 3) {
		if (($cprot==0 or $cprot==1) and $cType eq "N1") {
			$protType = 1;
		}
		elsif (($cprot==0 or $cprot==1 or $cprot==2) and $cType eq "N2") {
			$protType = 2;
		}
		elsif (($cprot==0 or $cprot==1 or $cprot==2 or  $cprot==3) and $cType eq "N3") {			
			$protType = 3;
		}		
		elsif (($cprot==0 or $cprot==4) and $cType =~ m/P/) {
			$protType = 4;
		}
		elsif (($cprot==1 and $cType =~ m/P/) or ($cprot==4 and $cType eq "N1") or ($cprot==5)) {
			$protType = 5;
		}
		elsif (($cprot==2 and $cType =~ m/P/) or ($cprot==5 and $cType eq "N2") or ($cprot==4 and $cType eq "N2") or ($cprot==6)) {
			$protType = 6;
		}			
		elsif(($cprot==4 and $cType eq "N3") or ($cprot==5 and $cType eq "N3") or ($cprot==6 and $cType eq "N3") or ($cprot==3 and $cType =~ m/P/)){
			$protType = 20;
		}		
		elsif($cprot==20) {
			$protType = 20;
		}
	}
	elsif ($inputs == 4) {
		if (($cprot==0 or $cprot==1) and $cType eq "N1") {
			$protType = 1;
		}
		elsif (($cprot==0 or $cprot==1 or $cprot==2) and $cType eq "N2") {
			$protType = 2;
		}
		elsif (($cprot==0 or $cprot==1 or $cprot==2 or $cprot==3) and $cType eq "N3") {
			$protType = 3;
		}
		elsif (($cprot==0 or $cprot==1 or $cprot==2 or $cprot==3 or $cprot==4) and $cType eq "N4") {
			$protType = 4;
		}
		elsif ($cprot==4 and $cType =~ m/P/) {			
			$protType = 20;
		}
		elsif (($cprot==0 or $cprot==5) and $cType =~ m/P/) {
			$protType = 5;
		}
		elsif (($cprot==1 and $cType =~ m/P/) or ($cprot==5 and $cType eq "N1") or ($cprot==6)) {
			$protType = 6;
		}
		elsif (($cprot==2 and $cType =~ m/P/) or ($cprot==6 and $cType eq "N2") or ($cprot==5 and $cType eq "N2") or ($cprot==7)) {
			$protType = 7;
		}
		elsif (($cprot==3 and $cType =~ m/P/) or ($cprot==7 and $cType eq "N3") or ($cprot==5 and $cType eq "N3") or ($cprot==6 and $cType eq "N3") or ($cprot==8)) {
			$protType = 8;
		}
		elsif (($cprot==8 and $cType eq "N4") or ($cprot==5 and $cType eq "N4") or ($cprot==6 and $cType eq "N4") or ($cprot==7 and $cType eq "N4")) {
			$protType = 20;
		}	
		elsif($cprot==20) {
			$protType = 20;
		}			
	}
	
	# print "Cprot = $cprot, CTYPE = $cType, Inputs = $inputs, Prot Type = $protType\n"; #$cin = getc(STDIN);
	return $protType;
}
#######################################################

sub getProtectionTypeNOR_OVER_PROTECTION {
	my $cprot = $_[0];	
	my $cType = $_[1];
	my $inputs = $_[2];
	
	$protType = 0;	
	
	################################################################
	# STATE MACHINE TO DECIDE THE  SELECTION TYPE BASED ON CURRENT
	# PROTECTION TYPE AND THE GATE TYPE.
	################################################################
	
	if ($inputs == 2) {
		if (($cprot==0 or $cprot==1) and $cType eq "P1") {
			$protType = 1;
		}
		elsif (($cprot==0 or $cprot==1) and $cType eq "P2") {
			$protType = 2;
		}
		elsif (($cprot==0 or $cprot==3) and $cType =~ m/N/) {
			$protType = 3;
		}
		elsif (($cprot==3 and $cType eq "P1") or ($cprot==1 and $cType =~ m/N/) or ($cprot==4)) {
			$protType = 4;
		}		
		elsif(($cprot==2 and $cType =~ m/N/) or ($cprot==3 and $cType eq "P2") or ($cprot==4 and $cType eq "P2")){
			$protType = 20;
		}		
		elsif($cprot==20) {
			$protType = 20;
		}
	}
	elsif ($inputs == 3) {
		if (($cprot==0 or $cprot==1) and $cType eq "P1") {
			$protType = 1;
		}
		elsif (($cprot==0 or $cprot==1 or $cprot==2) and $cType eq "P2") {
			$protType = 2;
		}
		elsif (($cprot==0 or $cprot==1 or $cprot==2 or  $cprot==3) and $cType eq "P3") {			
			$protType = 3;
		}		
		elsif (($cprot==0 or $cprot==4) and $cType =~ m/N/) {
			$protType = 4;
		}
		elsif (($cprot==1 and $cType =~ m/N/) or ($cprot==4 and $cType eq "P1") or ($cprot==5)) {
			$protType = 5;
		}
		elsif (($cprot==2 and $cType =~ m/N/) or ($cprot==5 and $cType eq "P2") or ($cprot==4 and $cType eq "P2") or ($cprot==6)) {
			$protType = 6;
		}			
		elsif(($cprot==4 and $cType eq "P3") or ($cprot==5 and $cType eq "P3") or ($cprot==6 and $cType eq "P3") or ($cprot==3 and $cType =~ m/N/)){
			$protType = 20;
		}		
		elsif($cprot==20) {
			$protType = 20;
		}
	}
	elsif ($inputs == 4) {
		if (($cprot==0 or $cprot==1) and $cType eq "P1") {
			$protType = 1;
		}
		elsif (($cprot==0 or $cprot==1 or $cprot==2) and $cType eq "P2") {
			$protType = 2;
		}
		elsif (($cprot==0 or $cprot==1 or $cprot==2 or $cprot==3) and $cType eq "P3") {
			$protType = 3;
		}
		elsif (($cprot==0 or $cprot==1 or $cprot==2 or $cprot==3 or $cprot==4) and $cType eq "P4") {
			$protType = 4;
		}
		elsif ($cprot==4 and $cType =~ m/N/) {			
			$protType = 20;
		}
		elsif (($cprot==0 or $cprot==5) and $cType =~ m/N/) {
			$protType = 5;
		}
		elsif (($cprot==1 and $cType =~ m/N/) or ($cprot==5 and $cType eq "P1") or ($cprot==6)) {
			$protType = 6;
		}
		elsif (($cprot==2 and $cType =~ m/N/) or ($cprot==6 and $cType eq "P2") or ($cprot==5 and $cType eq "P2") or ($cprot==7)) {
			$protType = 7;
		}
		elsif (($cprot==3 and $cType =~ m/N/) or ($cprot==7 and $cType eq "P3") or ($cprot==5 and $cType eq "P3") or ($cprot==6 and $cType eq "P3") or ($cprot==8)) {
			$protType = 8;
		}
		elsif (($cprot==8 and $cType eq "P4") or ($cprot==5 and $cType eq "P4") or ($cprot==6 and $cType eq "P4") or ($cprot==7 and $cType eq "P4")) {
			$protType = 20;
		}	
		elsif($cprot==20) {
			$protType = 20;
		}			
	}
	
	
	# print "Cprot = $cprot, CTYPE = $cType, Inputs = $inputs, Prot Type = $protType\n"; #$cin = getc(STDIN);
	return $protType;
}
#######################################################

sub readBenchFile {
	# print "\tReading $inputFile.bench file ... \n";
	# my $start_time = [Time::HiRes::gettimeofday()];
	
	$benchFile = "$inputFile.bench";
	print "B: $benchFile\n";
	open (INPUT_FILE, $benchFile) or die $!;
	
	$currentPO = ();
	$poIndexCounter = 0;
	my %tempCompleteGates = ();	
	%gateBelongings = (); 
	@primaryOutputs = ();
	@primaryInputs = ();
	@inter_IO_Gates = ();
	@allGates = ();
	@multiFanOuts = ();
	%poIndices = ();
	%inputs = ();
	%fanouts = ();
	%completeGates = ();
	%gatesCounter = ();
	%path = ();
		
	while(<INPUT_FILE>) {
		if ($_ =~ m/INPUT(.*)/) {		
			if ($1 =~ m/(\w+)/) {
				push (@primaryInputs, $1);	
			}
		}
		elsif ($_ =~ m/OUTPUT(.*)/) {
			if ($1 =~ m/(\w+)/) {
				push (@primaryOutputs, $1);					
			}
		}
		elsif ($_ =~ /#/ or $_ =~ /^\s/) {
			next;
		}		
		elsif ($_ =~ m/=/) {			
			
			my @gateList = ($_ =~ m/(\w+)/g);				
			$gateName[0] = $gateList[1];			
			@gateList = ($gateList[0], @gateList[2..$#gateList]);
				
						
			# print "@gateList,  Length = ", scalar @gateList, ", GN: $gateName[0],  POINDEX: $poIndexCounter\n";			
			# $cin=getc(STDIN); exit;
			
			if (grep {$_ eq $gateList[0]} @primaryOutputs) {
				$currentPO = shift(@primaryOutputs);
				push @primaryOutputs, $currentPO;
				$poIndices{$gateList[0]} = $poIndexCounter;
			}
			else {
				$currentPO = $primaryOutputs[0];
			}
						
			$gateBelongings{$gateList[0]} = $currentPO;
			
			#---------------------------------------------------
			# Create an output to input and input to output MAP
			#---------------------------------------------------
			my $connections = ();
			for my $i (1..scalar @gateList-1) {				
				$connections .= "$gateList[$i]";	
				if ((scalar @gateList > 1) && ($i < scalar @gateList-1)) {
					$connections .= "-";
				}
				
				if (exists($fanouts{$gateList[$i]})) {				
					$temp = $fanouts{$gateList[$i]};
					$fanouts{$gateList[$i]} = $temp."-".$gateList[0];
				}
				else {
					$fanouts{$gateList[$i]} = $gateList[0];	
				}				
			}
			$inputs{$gateList[0]} = $gateName[0]."-".$connections;	

			# if ($gateName[0] eq "NOT") {
				# if (grep {$_ eq $connections} @primaryInputs) {
					# $invertedInputs = $gateList[0];
				# }
			# }			
			
			push @inter_IO_Gates, $gateList[0];				
			#-------------------------------------------------
			
			for my $i(0..scalar @gateList - 1) {			
				if (!(exists($tempCompleteGates{$gateList[$i]}))) {				
					if ($i == 0) {					
						$tempCompleteGates{$gateList[$i]} = 0;	
						$gatesCounter{$gateList[$i]} = 0;
						$completeGates{$gateList[$i]} = 0;	
					}
					else {					
						$tempCompleteGates{$gateList[$i]} = $gateList[0];	
						$gatesCounter{$gateList[$i]} = 1;
						$completeGates{$gateList[$i]} = "$gateName[0]-$gateList[0]";	
					}
				}
				else {				
					$gatesCounter{$gateList[$i]}++;										
					if ($gatesCounter{$gateList[$i]} >= 2) {							
						$tempCompleteGates{"$gateList[$i]->$gateList[0]"} = $gateList[0];
						$tempCompleteGates{"$gateList[$i]->$tempCompleteGates{$gateList[$i]}"} = $tempCompleteGates{$gateList[$i]};												
						$gatesCounter{"$gateList[$i]->$gateList[0]"} = 0;
						$gatesCounter{"$gateList[$i]->$tempCompleteGates{$gateList[$i]}"} = 0;						
						
						if ($completeGates{$gateList[$i]} eq 0) {
							$completeGates{"$gateList[$i]->$gateList[0]"} = "$gateName[0]-$gateList[0]";	
						}
						else {
							$completeGates{"$gateList[$i]->$gateList[0]"} = "$gateName[0]-$gateList[0]";						
							@previousLine = split('-', $completeGates{$gateList[$i]});							
							$completeGates{"$gateList[$i]->$previousLine[1]"} = "$previousLine[0]-$previousLine[1]";					
							$completeGates{$gateList[$i]} = 0;
						}
					}
					else {	
						$tempCompleteGates{$gateList[$i]} = $gateList[0];							
						$completeGates{$gateList[$i]} = "$gateName[0]-$gateList[0]";													
					}
				}
			}					
			$poIndexCounter++;
		}		
	}	
	close(INPUT_FILE);	
	
	
	
	####################################################
	# Fanout Counter
	####################################################
	foreach my $node (%fanouts) {	
		
		if (exists($fanouts{$node})) {		
			# print "Node = $node, Fanouts = $fanouts{$node} \n";
			@row = split("-", $fanouts{$node});
			$fanoutCounter{$node} = scalar @row;
			if ($fanoutCounter{$node} > 1) { # and ($node =~ m/g/)) {
				push @multiFanOuts, $node;
			}			
		}
	}
	
	
	# my $run_time = Time::HiRes::tv_interval($start_time);
	# print "\tTime taken Reading Bench file = $run_time sec.\n\n";	
	
	@allGates = @{ dclone(\@inter_IO_Gates) };	
	@inter_IO_Gates = nsort @inter_IO_Gates;	
}
#######################################################

sub readFaultsFile {		
	print "\tReading $inputFile.fault file ... \n";
	my $start_time = [Time::HiRes::gettimeofday()];
	
	open (FILE, "$inputFile.fault") or die $!;		

	while (<FILE>) {
		chomp;
		if ($_ =~ m/\*/) {	
			$flag = 1;
			next;			
		}
		elsif($_ =~ m/Number of primary inputs(.*)/) {
			if ($1 =~ m/(\d+)/) 	{
				$numberOfPrimaryInputs = $1;
			}			
		}
		elsif($_ =~ m/Number of primary outputs(.*)/) {
			if ($1 =~ m/(\d+)/) 	{
				$numberOfPrimaryOutputs = $1;
			}			
		}
		elsif($_ =~ m/Number of combinational gates(.*)/) {
			if ($1 =~ m/(\d+)/) 	{
				$numberOfCombGates = $1;
			}			
		}
		elsif($_ =~ m/Number of flip-flops(.*)/) {
			if ($1 =~ m/(\d+)/) 	{
				$numberOfFF = $1;
			}			
		}
		elsif($_ =~ m/Level of the circuit(.*)/) {
			if ($1 =~ m/(\d+)/) 	{
				$numberOfLevels = $1;
			}			
		}
		elsif($_ =~ m/Number of test patterns applied(.*)/) {
			if ($1 =~ m/(\d+)/) 	{
				$numberOfTestVectors = $1;
			}			
		}
		elsif($_ =~ m/Number of collapsed faults(.*)/) {
			if ($1 =~ m/(\d+)/) 	{
				$numberOfCollapsedFaults = $1;
			}			
		}
		elsif($_ =~ m/Number of detected faults(.*)/) {
			if ($1 =~ m/(\d+)/) {
				$numberOfDetectedFaults = $1;
			}			
		}
		elsif($_ =~ m/Number of undetected faults(.*)/) {
			if ($1 =~ m/(\d+)/) {
				$numberOfUndetectedFaults = $1;				
			}			
		}
		elsif($_ =~ m/Fault coverage(.*)/) {
			if ($1 =~ m/(\d+\.\d+)/) {
				$faultCoverage = $1;
			}			
		}
		elsif (!$flag) {
			$row = [ split ];
			if (@$row[0] =~ m/test/) {					
				push @testVectors, @$row[2];
			}
			else {	
								
				if (!(exists($listOfGates{@$row[0]}))) {
					$listOfGates{@$row[0]} = 0;	
				}
				
				if (@$row[1] =~ m/(\d)/) {
					$faultValue =	$1;	
				}	
				
				# print "ROW: @$row[0], @$row[1], Value: $faultValue\n"; $cin=getc(STDIN);
				
				if ($faultValue == 1) {										
					if (exists($circuitFaults_original_1{@$row[0]})) {
						$circuitFaults_original_1{@$row[0]}++;	
					}
					else {
						$circuitFaults_original_1{@$row[0]} = 1;	
					}
				}
				else {
					if (exists($circuitFaults_original_0{@$row[0]})) {
						$circuitFaults_original_0{@$row[0]}++;	
					}
					else {
						$circuitFaults_original_0{@$row[0]} = 1;	
					}
				}					
			}
		}		
	}
	close(FILE);	
	my $run_time = Time::HiRes::tv_interval($start_time);
	print  "\tTime taken Reading Faults file = $run_time sec.\n\n";
	
	# print "sa0 \n";
	# print Dumper \%circuitFaults_original_0;
	# print "sa1 \n";
	# print Dumper \%circuitFaults_original_1;
	# print Dumper \%listOfGates;exit;
}
#######################################################

sub findEquivFaults {
	print "\tFinding Equivalent Faults ... \n";
	my $start_time = [Time::HiRes::gettimeofday()];
	
	%circuitFaults_0 = %{ clone (\%circuitFaults_original_0) };
	%circuitFaults_1 = %{ clone (\%circuitFaults_original_1) };
	
	# foreach (sort keys %gatesCounter) {
		# print "$_, ",$gatesCounter{$_}, " \n";
	# }
	# exit;
	
	# print "sa0 \n";
	# print Dumper \%circuitFaults_0;
	# print "sa1 \n";
	# print Dumper \%circuitFaults_1; exit;	

	#insert the non-existing faults in the hash table
	foreach $k (@inter_IO_Gates) {	
		if (!(exists($circuitFaults_0{$k}))) {
			$circuitFaults_0{$k} = 0;	
			$circuitFaults_original_0{$k} = 0;
		}
		if (!(exists($circuitFaults_1{$k}))) {
			$circuitFaults_1{$k} = 0;	
			$circuitFaults_original_1{$k} = 0;
		}		
	}	
	
	foreach $k (@primaryInputs) {	
		if (!(exists($circuitFaults_0{$k}))) {
			$circuitFaults_0{$k} = 0;	
			$circuitFaults_original_0{$k} = 0;
		}
		if (!(exists($circuitFaults_1{$k}))) {
			$circuitFaults_1{$k} = 0;	
			$circuitFaults_original_1{$k} = 0;
		}		
	}
			
	foreach $gate (@inter_IO_Gates) {		
		
		@FO = split('-', $inputs{$gate});		

		# print "Gate: $gate, @FO\n";
		# $cin=getc(STDIN);
		
		foreach $ii (1..scalar @FO - 1) {			
		
			if (($FO[0] =~ m/NAND/) and ($gatesCounter{$FO[$ii]} < 2)) {
				$circuitFaults_0{$FO[$ii]} = $circuitFaults_1{$gate};	
			}
			elsif (($FO[0] =~ m/AND/) and ($gatesCounter{$FO[$ii]} < 2)) {
				$circuitFaults_0{$FO[$ii]} = $circuitFaults_0{$gate};	
			}
			elsif (($FO[0] =~ m/NOT/) and ($gatesCounter{$FO[$ii]} < 2)) {					
				$circuitFaults_0{$FO[$ii]} = $circuitFaults_1{$gate};					
				$circuitFaults_1{$FO[$ii]} = $circuitFaults_0{$gate};								
			}			
			if (($FO[0] =~ m/NOR/) and ($gatesCounter{$FO[$ii]} < 2)) {
				$circuitFaults_1{$FO[$ii]} = $circuitFaults_0{$gate};		}
				
			elsif (($FO[0] =~ m/OR/) and ($gatesCounter{$FO[$ii]} < 2)) {
				$circuitFaults_1{$FO[$ii]} = $circuitFaults_1{$gate};	
			}
		}
	}
	my $run_time = Time::HiRes::tv_interval($start_time);

	print "\tTime taken finding Equivalent faults = $run_time sec.\n";		
	nstore \%circuitFaults_0, $inputFile."_sa0.prob";
	nstore \%circuitFaults_1, $inputFile."_sa1.prob";		
	
	# print "sa0 \n";
	# print Dumper \%circuitFaults_0;
	# print "sa1 \n";
	# print Dumper \%circuitFaults_1; exit;	
}
#######################################################

sub selectionAlgorithmWitAreaConstraint {
	
	my $overHead = $_[0];
	
	my @orderedGates = ();
	my @sensitiveNodes = ();
	my @IOs = ();
	my %outBenchFile = ();
	my %probOfFailure = ();
	my %protType = ();	
	my %gateConts_0 = ();
	my %gateConts_1 = ();
	my $currentArea = 0;
	my $currentNT = 0;
	my $targetArea = 0;
	
	my $newBenchFile = $inputFile."_AC_".($overHead*100).".bench";	
	
	%ipp = %{retrieve($inputFile.'.ipp')};
	%tech = %{retrieve('130nm.pf')};
	# print Dumper \%tech;
	
	my $start_time = [Time::HiRes::gettimeofday()];	
	
	
	#-----------------------------------------------#
	#Computing the area of current bench file
	#-----------------------------------------------#
	print "\n---Executing bench_to_spice on $inputFile\n\n";
	system ("perl bench_to_spice_45nm.pl $inputFile 1");
	
	open(IN,"$inputFile.sp") || die " Cannot open input file $inputFile".".v \n";	
	while(<IN>){
		if (/M_/) {
			$currentNT++;
		}	
	}
	close(IN);

	open(IN,"area.sp") || die " Cannot open input file area.sp \n";	
	while(<IN>){
		$currentArea = $_;
	}
	close(IN);
	system ("del area.sp");
	system ("del tranarea.dat");
	system ("del $inputFile.sp");	
	#-----------------------------------------------#
	
	#############################################################
	#	Read the Propagation Stats file of current circuit.		#
	#############################################################
	my %currentCircuitPropFailureProbs = ();
	$propFile = $inputFile.".prop";
	
	open (PROP_IN, $propFile) or die $!;
	while(<PROP_IN>) {
		chomp;
		@row = split('=>', $_);
		$currentCircuitPropFailureProbs{$row[0]} = $row[1];		
	}
	close(PROP_IN);	
	#############################################################
	
	
	#-------------------------------------------------------
	#	Area overdhead calculation based on either number
	#	of transistors or cummulative drain area of all
	# 	the transistors.				
	#-------------------------------------------------------
	$targetArea = $currentArea + ($currentArea*$overHead);
	# $targetArea =  $currentArea + ($actual_Area{$inputFile}*$overHead);		
	
	#Modified Target Area in case of DMR 	
	# $targetArea = $actual_Area{$inputFile} + ($actual_Area{$inputFile}*$overHead);	
	#-------------------------------------------------------
		
	print "\n\tExecuting Selection Algorithm with ".($overHead*100)."% Area Constraint... \n\n";	
	
	# print "---Circuit ====> $inputFile\n";
	# print "---Number of transistors = $currentNT \n";
	# print "---Area = $currentArea \n";
	# print "---Target Area = $targetArea\n";
	#-----------------------------------------------#
	
	#---------------------------------------------------#
	#	Save each gate in the circuit along with 		#
	#   the prob. of failure of each transistor			# 
	#	in HASH structure. 								#
	#---------------------------------------------------#
	open (INPUT_FILE, $benchFile) or die $!;	
	while (<INPUT_FILE>) {	
		if (/=/) {				
			my @gateList = split(" = ", $_);
			$gateList[1] = "= ".$gateList[1];			
						
			$currentGate = $gateList[0];				
			$outBenchFile{$currentGate} = $gateList[1];		
			push @orderedGates, $currentGate;
			
			$protType{$currentGate} = "0_0"; #Initialize the protection type of each senstive gate to 0
			
			
			#-----------------------------------------------------------#
			#	Compute Probability of failure of each transistor of	#
			#	the current selected gate.								#
			#-----------------------------------------------------------#
			
			#-------------------------------------------------
			#Generate the remaining parts of final bench file
			#-------------------------------------------------			
			@gateList = ($_ =~ m/(\w+)/g);				
			$gateName[0] = $gateList[1];			
			@gateList = ($gateList[0], @gateList[2..$#gateList]);		
						
			$currentGate = $gateList[0];	
			@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.	
			$gateName = $inputs[0];
						
			my $errorType = -1;
			my $gateType = ();
						
			$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate}/$numberOfTestVectors);
			$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate}/$numberOfTestVectors);			
								
			# process the Gates			
			my $nType = 0;
			my $pType = 0;
			my $nmos = 0;
			my $pmos = 0;
				
			#iterate through all the N-type and P-Type transistors.
			for ($ii = 1; $ii < scalar @inputs; $ii++) {
				$nmos = "N".$ii;
				$pmos = "P".$ii;	

				#Compute gate controllability from the .ipp file, only once for each gate
				if ($ii==1) {
				
					#FOR NMOS
					# Read the generic failed vectors for N1
					@failedVectors = ();
					$protType2 = $gateName.(scalar @inputs - 1);					
					$nmos1 = $protType2."-N$ii";					
					
					for $vector ( keys %{ $tech{$nmos1} } ) {
						push @failedVectors, $vector;						
					}					
					
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$currentGate} } ) {
						push @currentFailedVectors, $vector;						
					}
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
					
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 							
					}
					$gateConts_0{$currentGate} = $freq;
						
					#FOR PMOS
					# Read the generic failed vectors for P-Type
					@failedVectors = ();	
					$protType2 = $gateName.(scalar @inputs - 1);					
					$pmos1 = $protType2."-P$ii";
					
					for $vector ( keys %{ $tech{$pmos1} } ) {
						push @failedVectors, $vector;						
					}					
					
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$currentGate} } ) {
						push @currentFailedVectors, $vector;						
					}
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
				
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 
					}
					$gateConts_1{$currentGate} = $freq;
					
					if ($gateConts_0{$currentGate}==0) {	$gateConts_0{$currentGate} = 1;	}
					if ($gateConts_1{$currentGate}==0) {	$gateConts_1{$currentGate} = 1;	}					
				}
					
				$currentNode_N = $currentGate."-$nmos";
				$currentNode_P = $currentGate."-$pmos";
				
				if ($currentCircuitPropFailureProbs{$currentNode_N}*$sa0 > 0) {
					$probOfFailure{$currentNode_N} = $currentCircuitPropFailureProbs{$currentNode_N}*$sa0/$gateConts_0{$currentGate};
				}
				
				if ($currentCircuitPropFailureProbs{$currentNode_P}*$sa1 > 0) {
					$probOfFailure{$currentNode_P} = $currentCircuitPropFailureProbs{$currentNode_P}*$sa1/$gateConts_1{$currentGate};					
				}
				
				# print "Current Gate = $currentGate, inputs = @inputs\n";
				# print "Prob SA0 = $sa0, $currentNode_N = $currentCircuitPropFailureProbs{$currentNode_N}\n";
				# print "Scaled $nmos = $probOfFailure{$currentNode_N}\n";
				
				# print "Prob SA1 = $sa1, $pmos = $currentCircuitPropFailureProbs{$currentNode_P}\n";
				# print "Scaled $pmos = $probOfFailure{$currentNode_P}\n\n";					
			}					
		}		
		elsif ($_ =~ /INPUT|OUTPUT/) {
			push @IOs, $_;
		}
	} #End of Main while loop
	close(INPUT_FILE);
	
	#Sort the gates according to their prob. of failure detection
	foreach my $name (sort { $probOfFailure{$b} <=> $probOfFailure{$a} or $a cmp $b } keys %probOfFailure) {				
		push @sensitiveNodes, $name;			
	}
	
	# print "\n\n-----------------------\n";
	# print "After Sorting\n";
	# print "-----------------------\n";
	# foreach my $name (@sensitiveNodes) {		
		# printf "%-s --> %s\n", $name, $probOfFailure{$name};		
	# } 	
	# -----------------------------------------------#			
	
	#-------------------------------------------------------------------#
	#	Computing the final bench file with area overhead constraint	#		
	#-------------------------------------------------------------------#
	while ($currentArea <= $targetArea) {
		my $replacement = ();
		my $replacementType = (); # To store the number of inputs for the current replacement in Quadded case only
		
		# Get a sensitive gate out of the list
		$currentNode = shift(@sensitiveNodes);
		@row = split("-", $currentNode);		
		$currentGate = $row[0];
		$currentType = $row[1]; # i.e. nmos or pmos
		@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.								
		$gateName = $inputs[0]; 		

		# print "CG = $currentNode, INPUTS = $inputs{$currentGate}  $gateName\n"; #$cin=getc(STDIN);		
				
		#	Process the gates
		$name = $gateName.(scalar @inputs - 1)."-$currentType";
		@row = split ("_", $protType{$currentGate});		
		
		# print "\n\nCurrent Node = $currentNode, Scaled Prob. of Failure = $probOfFailure{$currentNode}\n";
		# print "Current Gate = $currentGate, Gate Name = $gateName\n";				
		# print "Inputs = @inputs, # of Inputs = ",(scalar @inputs - 1),", Name = $name\n"; 			
		# print "========>Current Node = $currentNode";
		$temp = $areaDrain{$name} + $currentArea;
		# print "Current Area = $currentArea, Area after current protection = $temp, Final Target Area = $targetArea\n";
		
		if ( $temp <= $targetArea )  { #make the protection
			$currentArea += $areaDrain{$name};
			
			if ($currentType =~ m/N/) { # and $probOfFailure{$currentNode} > 0) { # i.e if nmos					
				$row[0]++;
				$protType{$currentGate} = "$row[0]_$row[1]";				
				$probOfFailure{$currentNode} = 0;				
				
				if ($gateName =~ m/NAND/) {
					#######################################
					#Update DPs of NAND GATE				
					#######################################
					$protType2 = $gateName.(scalar @inputs - 1).$row[0];
					
					#The current node is protected, we only need to update the DPs
					#of the remaining nmos tansistors of the current NAND gate only according
					#to protType2.
					
					# Read the generic failed vectors for N-Type
					foreach $kl (2..scalar @inputs - 1) {
						@failedVectors = ();						
						$nmos = $protType2."-N$kl";
						for $vector ( keys %{ $tech{$nmos} } ) {
							push @failedVectors, $vector;						
						}
						
						
						# Read the failed vectors for current gate in the current circuit
						@currentFailedVectors = ();
						for $vector ( keys %{ $ipp{$currentGate} } ) {
							push @currentFailedVectors, $vector;						
						}
						
						@isect = intersect(@failedVectors, @currentFailedVectors);
						
						$freq=0;
						foreach $value (@isect) {							
							$freq += $ipp{$currentGate}{$value}; 
						}
						
						$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate}/$numberOfTestVectors);
						$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate}/$numberOfTestVectors);
						
						$nodeProbToUpdate = $currentGate."-N$kl";
						$probOfFailure{$nodeProbToUpdate} = $freq*$sa0/$gateConts_0{$currentGate};
						
						#Sort the gates according to their prob. of failure detection
						@sensitiveNodes = ();
						foreach my $name (sort { $probOfFailure{$b} <=> $probOfFailure{$a} or $a cmp $b } keys %probOfFailure) {				
							push @sensitiveNodes, $name;			
						}
												
						# print "\nUpdate Node = $nodeProbToUpdate, protType2 = $protType2,  CG = $currentGate\n";
						# print "OV = @failedVectors\n";
						# print "CV = @currentFailedVectors\n";
						# print "FREQ = $freq, scaled = ",$freq*$sa0,"\n";
						# print "sa0 = $sa0, sa1 = $sa1\n";					
					}			
					
					#######################################				
				}				
			}
			elsif ($currentType =~ m/P/) { # and $probOfFailure{$currentNode} > 0) { # i.e if pmos	
				$row[1]++;
				$protType{$currentGate} = "$row[0]_$row[1]";	
				$probOfFailure{$currentNode} = 0;				
				
				if ($gateName =~ m/NOR/) {
					#######################################
					#Update DPs of NOR GATE				
					#######################################
					$protType2 = $gateName.(scalar @inputs - 1).$row[1];
					
					#The current node is protected, we only need to update the DPs
					#of the remaining pmos tansistors of the current NOR gate only according
					#to protType2.
					
					# Read the generic failed vectors for P-Type
					foreach $kl (2..scalar @inputs - 1) {
						@failedVectors = ();						
						$pmos = $protType2."-P$kl";
						for $vector ( keys %{ $tech{$pmos} } ) {
							push @failedVectors, $vector;						
						}
						
						
						# Read the failed vectors for current gate in the current circuit
						@currentFailedVectors = ();
						for $vector ( keys %{ $ipp{$currentGate} } ) {
							push @currentFailedVectors, $vector;						
						}
						
						@isect = intersect(@failedVectors, @currentFailedVectors);
						
						$freq=0;
						foreach $value (@isect) {							
							$freq += $ipp{$currentGate}{$value}; 
						}
						
						$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate}/$numberOfTestVectors);
						$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate}/$numberOfTestVectors);
						
						$nodeProbToUpdate = $currentGate."-P$kl";
						$probOfFailure{$nodeProbToUpdate} = $freq*$sa1/$gateConts_1{$currentGate};
						
						#Sort the gates according to their prob. of failure detection
						@sensitiveNodes = ();
						foreach my $name (sort { $probOfFailure{$b} <=> $probOfFailure{$a} or $a cmp $b } keys %probOfFailure) {				
							push @sensitiveNodes, $name;			
						}
												
						# print "\nUpdate Node = $nodeProbToUpdate, protType2 = $protType2,  CG = $currentGate\n";
						# print "OV = @failedVectors\n";
						# print "CV = @currentFailedVectors\n";
						# print "FREQ = $freq, scaled = ",$freq*$sa1,"\n";
						# print "sa0 = $sa0, sa1 = $sa1\n";				
						
					}			
					
					#######################################				
				}				
			}
			# print "\n==========>nType = $row[0], pType = $row[1]\n\n";
			
			
			# print "After Sorting2\n";
						# print "-----------------------\n";
						# foreach my $name (@sensitiveNodes) {		
							# printf "%-s --> %s\n", $name, $probOfFailure{$name};		
						# } 		
		}
		else {
			last; # STOP applying the protection and exit the main while loop.				
		}	
				
		if (scalar @sensitiveNodes==0) {
			last;
		}		
	} # end of master WHILE LOOP
		
	#-----------------------------------------------	
	
	# foreach my $name (@orderedGates) {		
		# printf "%-s --> %s\n", $name, $protType{$name};		
	# }
	# print "Final Area = $currentArea\n";	
	
	#------------------------------------------------------	
	#	Writing the final bench file by iterating through
	#	all the gates and based on their nType and pType
	#	variable values, apply suitable protection.
	#------------------------------------------------------	
	open (OUTPUT_Bench, ">$newBenchFile") or die $!;
	print OUTPUT_Bench "#Protection with Area Overhead Constraint of ".($overHead*100)."%\n";
	print OUTPUT_Bench "\n";
	print OUTPUT_Bench @IOs;
	print OUTPUT_Bench "\n";
	
	foreach $currentGate (@orderedGates) {
	
		# print OUTPUT_Bench "$currentGate $outBenchFile{$currentGate}";	
		@row = split("_", $protType{$currentGate});
		$nType = $row[0];
		$pType = $row[1];
		$errorType = -1;
				
		@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.			
		$gateName = $inputs[0]; 	 
		
		if ($gateName eq "NAND") {
			if (($nType > 0 and $pType > 0) and ($nType==$pType)) {
					$errorType = 2;					
				}
			elsif($nType > 0 and $pType==0) {
				$gateType = "NAND".(scalar @inputs - 1).$nType;
				$errorType = 0;
			}
			elsif($nType==0 and $pType > 0) {
				$gateType = "NAND".(scalar @inputs - 1).((scalar @inputs - 1)+1);
				$errorType = 1;
			}
			elsif($nType > 0 and $pType > 0) {
				$gateType = "NAND".(scalar @inputs - 1).((scalar @inputs - 1)+1+$nType);
				$errorType = 1;
			}
			else {
				$gateType = $gateName;
			}	
		}
		elsif ($gateName eq "NOR") {
			if (($nType > 0 and $pType > 0) and ($nType==$pType)) {
				$errorType = 2;					
			}
			elsif($pType > 0 and $nType==0) {
				$gateType = "NOR".(scalar @inputs - 1).$pType;
				$errorType = 1;
			}
			elsif($nType > 0 and $pType==0) {
				$gateType = "NOR".(scalar @inputs - 1).((scalar @inputs - 1)+1);
				$errorType = 0;
			}
			elsif($nType > 0 and $pType > 0) {
				$gateType = "NOR".(scalar @inputs - 1).((scalar @inputs - 1)+1+$pType);
				$errorType = 0;
			}
			else {
				$gateType = $gateName;
			}	
		}
		elsif ($gateName eq "NOT") {
			if ($nType > 0 and $pType > 0) {
				$errorType = 2;					
			}
			elsif($nType > 0 and $pType==0) {
				$gateType = "NOT1";
				$errorType = 0;
			}
			elsif($nType==0 and $pType > 0) {
				$gateType = "NOT2";
				$errorType = 1;
			}
			else {
				$gateType = $gateName;
			}
		}
		
		if (($errorType == 2 )) { # or (grep {$_ eq $currentGate} @primaryOutputs)) {						
				print OUTPUT_Bench "$currentGate = D".$gateName."(";				
				
				for ($ii = 1; $ii < scalar @inputs; $ii++) {					
					if ($ii  == scalar @inputs - 1)	
					{	print OUTPUT_Bench "$inputs[$ii])\n";	}
					else
					{	print OUTPUT_Bench "$inputs[$ii], ";	}											
				}											
			}
		elsif ($errorType == 0 or $errorType = 1) {
			
			print OUTPUT_Bench "$currentGate = $gateType(";				
				
			for ($ii = 1; $ii < scalar @inputs; $ii++) {					
				if ($ii  == scalar @inputs -1) {
					print OUTPUT_Bench "$inputs[$ii])\n";	
				}
				else {
					print OUTPUT_Bench "$inputs[$ii], ";	
				}
			}		
			$isDuplicate{$currentGate} = 1;				
		}			
		else {
			print OUTPUT_Bench $_;	
		}	
		
		if (grep $_ eq $currentGate, @primaryOutputs) {
		print OUTPUT_Bench "\n";
		}
	}
	close(OUTPUT_Bench);	
	#-------------------------------------------------------------
	
	my $run_time = Time::HiRes::tv_interval($start_time);
	print "\tTime taken to create Bench File = $run_time sec.\n";	
}
#######################################################

sub createReliableBenchFileWithAllQuad {
	$replicationType = "RQ";
	print "\n\tCreating final .bench file ... \n";
	
	my $newBenchFile = $inputFile."RQ.bench";	
	
	my $start_time = [Time::HiRes::gettimeofday()];	
	open (OUTPUT_Bench,  ">$newBenchFile") or die $!;
	
	#-----------------------------------------------
	#Generate Inputs and outputs of a new bench file
	#-----------------------------------------------
	open (INPUT_FILE, $benchFile) or die $!;	
	while (<INPUT_FILE>) {	
		if (/=/) {	
		
			#-------------------------------------------------
			#Generate the remaining parts of final bench file
			#-------------------------------------------------			
			my @gateList = ($_ =~ m/(\w+)/g);				
			$gateName[0] = $gateList[1];			
			@gateList = ($gateList[0], @gateList[2..$#gateList]);		
			
			$currentGate = $gateList[0];			
				
			@inputs = split("-", $inputs{$currentGate});		
			
			print OUTPUT_Bench "$currentGate = Q".$gateName[0]."(";				
				
			for ($ii = 1; $ii < scalar @inputs; $ii++) {					
				if ($ii  == scalar @inputs - 1)	
				{	print OUTPUT_Bench "$inputs[$ii])\n";	}
				else
				{	print OUTPUT_Bench "$inputs[$ii], ";	}											
			}			
			#-------------------------------------------------
		}
		else {
			print OUTPUT_Bench $_;	
		}
	}	
	close(INPUT_FILE);
	#-----------------------------------------------	
	
	close(OUTPUT_Bench);	
	
	my $run_time = Time::HiRes::tv_interval($start_time);
	print "\tTime taken to create Bench File = $run_time sec.\n";
	
	print "\n\n\tInputs = @primaryInputs \n";
	print "\n\n\tOutputs = @primaryOutputs \n";		
}
#######################################################

sub selectionAlgorithmWithPOFSUpdate_GREEDY {
	
	my $thValue = $_[0];
			
	my @orderedGates = ();
	my @sensitiveNodes = ();
	my @processedNodes = ();
	my @IOs = ();
	my %outBenchFile = ();
	my %probOfFailure = ();
	my %probOfFailure_COPY = ();
	my %detectionProb = ();
	my %strikeProb = ();
	my %protType = ();	
	my %gateConts_0 = ();
	my %gateConts_1 = ();
	my %currentCircuitGateAreas = ();	
	my %nodeAreas = ();
	my $currentArea = 0;
	my $currentNT = 0;
	my $targetArea = 0;
	
	my $verbosity = 0;
		
	%ipp = %{retrieve($inputFile.'.ipp')};
	%tech = %{retrieve('130nm.pf')};
	# print Dumper \%ipp;
	
	# my @ths = qw (0.05 0.02 0.01);
	my @ths = qw (0.01);
	
	my $start_time = [Time::HiRes::gettimeofday()];	
	
	$nmosDrainArea = 0.09;
	$pmosDrainArea = 0.18;
	
	################################################
	# Get Area of current Circuit
	################################################
	system ("perl bench_to_spice_45nm.pl $inputFile 1");
	open(IN,"area.sp") || die " Cannot open input file area.sp \n";
	$circuitArea=0;	# area of circuit
	while(<IN>){
		$circuitArea = $_;
	}
	close(IN);
	system ("del area.sp");
	system ("del $inputFile.sp");
	
	# $circuitArea = 42.12;
	# $circuitArea = 338.31;
	# $circuitArea = 1047.33;
	
	# $circuitArea = 1.08;
	# $circuitArea = 3.150;
	
	#############################################################
	#	Read the Propagation Stats file of current circuit.		#
	#############################################################
	my %currentCircuitPropFailureProbs = ();
	$propFile = $inputFile.".prop";
	
	open (PROP_IN, $propFile) or die $!;
	while(<PROP_IN>) {
		chomp;
		@row = split('=>', $_);
		$currentCircuitPropFailureProbs{$row[0]} = $row[1];		
	}
	close(PROP_IN);	
	#############################################################
	
	#---------------------------------------------------#
	#	Save each gate in the circuit along with 		#
	#   the prob. of failure of each transistor			# 
	#	in HASH structure. 								#
	#---------------------------------------------------#
	open (INPUT_FILE, $benchFile) or die $!;	
	while (<INPUT_FILE>) {	
		if (/=/) {				
			my @gateList = split(" = ", $_);
			$gateList[1] = "= ".$gateList[1];			
						
			$currentGate = $gateList[0];				
			$outBenchFile{$currentGate} = $gateList[1];		
			push @orderedGates, $currentGate;
			
			$protType{$currentGate} = 0; #Initialize the protection type of each senstive gate to 0			
			
			#-----------------------------------------------------------#
			#	Compute Probability of failure of each transistor of	#
			#	the current selected gate.								#
			#-----------------------------------------------------------#
			
			#-------------------------------------------------
			#Generate the remaining parts of final bench file
			#-------------------------------------------------			
			@gateList = ($_ =~ m/(\w+)/g);				
			$gateName[0] = $gateList[1];			
			@gateList = ($gateList[0], @gateList[2..$#gateList]);		

			$currentGate = $gateList[0];	
			@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.	
			$gateName = $inputs[0]; 	
			
			$currentCircuitGateAreas{$currentGate} = $gateArea{$gateName.(scalar @inputs-1)};
			
			my $errorType = -1;
			my $gateType = ();
						
			$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate}/$numberOfTestVectors);
			$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate}/$numberOfTestVectors);			
								
			# process the Gates			
			my $nType = 0;
			my $pType = 0;
			my $nmos = 0;
			my $pmos = 0;			
				
			#iterate through all the N-type and P-Type transistors.
			for ($ii = 1; $ii < scalar @inputs; $ii++) {
				$nmos = "N".$ii;
				$pmos = "P".$ii;					
				
				#Compute gate controllability from the .ipp file, only once for each gate
				if ($ii==1) {
				
					#FOR NMOS
					# Read the generic failed vectors for N1
					@failedVectors = ();
					$nmos1 = $gateName.(scalar @inputs - 1)."-N$ii";						
					
					for $vector ( keys %{ $tech{$nmos1} } ) {
						push @failedVectors, $vector;						
					}										
				
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$currentGate} } ) {
						push @currentFailedVectors, $vector;						
					}
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
					
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 							
					}
					$gateConts_1{$currentGate} = $freq;
						
					#FOR PMOS
					# Read the generic failed vectors for P-Type
					@failedVectors = ();	
					$pmos1 = $gateName.(scalar @inputs - 1)."-P$ii";	
										
					for $vector ( keys %{ $tech{$pmos1} } ) {
						push @failedVectors, $vector;						
					}					
					
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$currentGate} } ) {
						push @currentFailedVectors, $vector;						
					}				
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
				
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 
					}
					$gateConts_0{$currentGate} = $freq;
					
					if ($gateConts_1{$currentGate}==0) {	$gateConts_1{$currentGate} = 1;	}
					if ($gateConts_0{$currentGate}==0) {	$gateConts_0{$currentGate} = 1;	}					
				}				
								
				$currentNode_N = $currentGate."-$nmos";
				$currentNode_P = $currentGate."-$pmos";
				
				if ($currentCircuitPropFailureProbs{$currentNode_N}*$sa0 > 0) {
					$detectionProb{$currentNode_N}	=	$currentCircuitPropFailureProbs{$currentNode_N}*$sa0/$gateConts_1{$currentGate};
					$strikeProb{$currentNode_N} 	=	$nmosDrainArea/$circuitArea;
					$nodeAreas{$currentNode_N} = $nmosDrainArea;
					$probOfFailure{$currentNode_N}	= 	$detectionProb{$currentNode_N}*$strikeProb{$currentNode_N};					
				}
				else {
					$detectionProb{$currentNode_N}	= 0;					
					$probOfFailure{$currentNode_N} = 0;						
					$nodeAreas{$currentNode_N} = $nmosDrainArea;
				}
								
				if ($currentCircuitPropFailureProbs{$currentNode_P}*$sa1 > 0) {
					$detectionProb{$currentNode_P}	=	$currentCircuitPropFailureProbs{$currentNode_P}*$sa1/$gateConts_0{$currentGate};
					$strikeProb{$currentNode_P} 	=	$pmosDrainArea/$circuitArea;
					$nodeAreas{$currentNode_P} = $pmosDrainArea;
					$probOfFailure{$currentNode_P}	= 	$detectionProb{$currentNode_P}*$strikeProb{$currentNode_P};					
				}
				else {
					$detectionProb{$currentNode_P}	= 0;
					$probOfFailure{$currentNode_P}  = 0;
					$nodeAreas{$currentNode_P} = $pmosDrainArea;
				}								
				# if ($currentGate eq "g" or $verbosity == 1) {
					# print "Current Gate = $currentGate, inputs = @inputs, $nmos1 Area = $nmosDrainArea, $pmos1 Area = $pmosDrainArea, Total Area = $circuitArea\n";
					# print "Node = $currentNode_N, Prob SA0 = $sa0, PC1 = $gateConts_1{$currentGate}, IPP = $currentCircuitPropFailureProbs{$currentNode_N}\n";
					# print "$currentNode_N: DET = $detectionProb{$currentNode_N}, Strike = $strikeProb{$currentNode_N},  POF $nmos = $probOfFailure{$currentNode_N}\n\n";					
					# print "Node = $currentNode_P, Prob SA1 = $sa1, PC0 = $gateConts_0{$currentGate}, IPP = $currentCircuitPropFailureProbs{$currentNode_P}\n";
					# print "$currentNode_P: DET = $detectionProb{$currentNode_P}, Strike = $strikeProb{$currentNode_P},  POF $pmos = $probOfFailure{$currentNode_P}\n\n";			
				# }				
			}					
		}		
		elsif ($_ =~ /INPUT|OUTPUT/) {
			push @IOs, $_;
		}
	} #End of Main while loop
	close(INPUT_FILE);
	
	#Sort the gates according to their prob. of failure detection	
	foreach my $name (sort { $probOfFailure{$b} <=> $probOfFailure{$a} or $a cmp $b } keys %probOfFailure) {					
		push @sensitiveNodes, $name;	
		# print "Name: $name\n";
	}
	# print Dumper \%nodeAreas; exit;
	# print "\nNodes = @sensitiveNodes\n\n";
	$totalNodes = scalar @sensitiveNodes;
	
	$POF = 0;	
	foreach my $name (@sensitiveNodes) {			
		$POF += $probOfFailure{$name};				
	}
	
	printf "==>Initial POF = %0.4f, Area = $circuitArea, TH = %0.4f, Total Nodes = $totalNodes\n", $POF*100, $thValue*100;	
	%POF_ORIGINAL =  %{ dclone(\%probOfFailure) };	
		
	##############################################################
	#Compute Gains of each protection
	##############################################################	
	@allNodes = @{ dclone(\@sensitiveNodes) }; 
	%areaOH = ();
	# $cn = "v";
	foreach my $currentNode (@sensitiveNodes) {
	
		%detectionProb_COPY = ();
		%strikeProb_COPY = ();
		$protectionType = 0;	
		$circuitArea_T = 0;
		
		@row = split("-", $currentNode);				
		$currentGate = $row[0];
		$currentType = $row[1]; # i.e. nmos or pmos		
		@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.										
		$gateName = $inputs[0]; 	
				
		if ($gateName eq "NAND") {
			$protectionType = getProtectionTypeNAND_NORMAL($protType{$currentGate}, $currentType, (scalar @inputs - 1));			
		}
		elsif ($gateName eq "NOR") {
			$protectionType = getProtectionTypeNOR_NORMAL($protType{$currentGate}, $currentType, (scalar @inputs - 1));		
		}		
		elsif ($gateName eq "NOT") {
			$protectionType = getProtectionTypeNOT($protType{$currentGate}, $currentType, (scalar @inputs - 1));									
		}		
		
		# protecting the type e.g., NAND21, NAND32, NAND43 etc.
		$redundancyModel	=	$gateName.(scalar @inputs - 1).$protectionType;		 

		#Update Circuit Area
		$newArea = $gateArea{$redundancyModel};
		$oldArea = $currentCircuitGateAreas{$currentGate};
		$overHead = $newArea - $oldArea;				
		$circuitArea_T = $circuitArea+$overHead;
		$areaOH{$currentNode} = $circuitArea_T-$circuitArea; 
		
		@nodesToUpdate = ();
		if ($inputs[0] eq "NAND" or $inputs[0] eq "NOR") {
			for $kk (1..scalar @inputs -1) {
				push @nodesToUpdate, $currentGate."-N$kk";		
			}
			for $kk (1..scalar @inputs -1) {
				push @nodesToUpdate, $currentGate."-P$kk";			
			}			
		}			
		elsif ($inputs[0] eq "NOT") {				
			push @nodesToUpdate, $currentGate."-N1";
			push @nodesToUpdate, $currentGate."-P1";						
		}
				
		# if ($currentNode eq $cn or $verbosity ==1) {
			# print "\n*******************************************************************************\n";
			# print "========>Current Node = $currentNode, POF = $probOfFailure{$currentNode}\n"; 
			# print "Gate Name = $gateName, # of Inputs = ",(scalar @inputs - 1),", NEW GATE AREA = $newArea, OLD GATE AREA = $oldArea, Circuit Area: AP = $circuitArea_T, BP = $circuitArea\n"; 			
			# print "Prot Type = $protectionType, Current Prot = $protType{$currentGate}, CTYPE = $currentType, R Model = $redundancyModel, @nodesToUpdate\n\n";			
		# } 
	
		# Iterate through the transistors list to update their POFs	if protection is applied on current nodes.
		foreach my $node (@allNodes) {
		
			@failedVectors = ();	

			@row = split("-", $node);				
			$CG = $row[0];
			$cType = $row[1]; # i.e. nmos or pmos	
									
			if (grep {$_ eq $node} @nodesToUpdate) {
				$trans = $redundancyModel."-$cType";					
				
				for $vector ( keys %{ $tech{$trans} } ) {
					push @failedVectors, $vector;						
				}					
		
				# Read the failed vectors for current gate in the current circuit
				@currentFailedVectors = ();
				for $vector ( keys %{ $ipp{$CG} } ) {
					push @currentFailedVectors, $vector;						
				}
				
				@isect = intersect(@failedVectors, @currentFailedVectors);
												
				$freq=0;
				foreach $value (@isect) {							
					$freq += $ipp{$currentGate}{$value}; 
				}
				
				$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate}/$numberOfTestVectors);
				$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate}/$numberOfTestVectors);									
					
				$drainArea = $transArea{$trans};			
															
				$gateContProb = 0;
				$stuckAtProb = 0;
				
				if ($cType =~ m/N/i) {
					$gateContProb = $gateConts_1{$CG};
					$stuckAtProb = $sa0;
				}
				else {
					$gateContProb = $gateConts_0{$CG};
					$stuckAtProb = $sa1;
				}
				
				$detectionProb_COPY{$node}				=	$freq*$stuckAtProb/$gateContProb;
				$strikeProb_COPY{$node} 				=	$drainArea/$circuitArea_T;				
				$probOfFailure_TRANS{$node}				= 	$detectionProb_COPY{$node}*$strikeProb_COPY{$node};				
				$probOfFailure_COPY{$currentNode}		+= 	$detectionProb_COPY{$node}*$strikeProb_COPY{$node};
			
				# if ($currentNode eq $cn or $verbosity ==1) {
					# print "Update Node = $node, protType = $protectionType,  CG = $currentGate, $trans Area = $drainArea, Total Area = $circuitArea_T\n";
					# print "Prob SA0 = $sa0, SA1 = $sa1, STUCK AT = $stuckAtProb, PC0 = $gateConts_0{$currentGate}, PC1 = $gateConts_1{$currentGate}, IPP = $currentCircuitPropFailureProbs{$node}, Current Cont. Prob = $gateContProb\n";		
					# print "Failed Vecs. = @failedVectors\n";
					# print "Current IPP = @currentFailedVectors\nCommon = @isect\n";						
					# print "$node: DET = $detectionProb_COPY{$node}, Strike = $strikeProb_COPY{$node}, T-AREA = $drainArea, POF $node = $probOfFailure_TRANS{$node}\n\n";						
				# }		
			}
			else { #For these transistors only the detection probability is changed.
				if ($cType =~ m/N/i) {
					$drainArea = $nmosDrainArea;
				}
				else {
					$drainArea = $pmosDrainArea;
				}
				
				$strikeProb_COPY{$node} 			=	$drainArea/$circuitArea_T;			
				$probOfFailure_TRANS{$node}			= 	$detectionProb{$node}*$strikeProb_COPY{$node}; 
				$probOfFailure_COPY{$currentNode}	+= 	$detectionProb{$node}*$strikeProb_COPY{$node}; 
				
				# if ($currentNode eq $cn or $verbosity ==1) {
					# print "$node After: DET= $detectionProb{$node}, HIT = $strikeProb_COPY{$node}, T-AREA = $drainArea, POF-$node=$probOfFailure_TRANS{$node}\n\n"; 
				# }			
			}												
		}
		# if ($currentNode eq $cn or $verbosity ==1) {
			# print "==>POF After protecting $currentNode = $probOfFailure_COPY{$currentNode}, Gain = ",$probOfFailure_COPY{$currentNode}-$POF,"\n";
			# print "==========================================================================\n\n";			
		# }
	}			
	#############################################################
	
	# print "*************************************************\n";					
	%Gain = ();
	%netGain = ();
	foreach my $name (@sensitiveNodes) {			
		$Gain{$name} = $probOfFailure_COPY{$name} - $POF;			
		$netGain{$name} = $Gain{$name}/$areaOH{$name};			
		# printf "Name: $name, PD=%0.4f, PH=%0.4f, POF=%0.4f\n",$detectionProb{$name}, $strikeProb{$name}, $probOfFailure{$name};
	}	
	
	# print "Initial Gains \n";
	@sensitiveNodes = ();
	foreach my $name (sort { $netGain{$a} <=> $netGain{$b} or $a cmp $b } keys %netGain) {	
	
		# @row = split("-", $name);				
		# $currentGate = $row[0];
		# @inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.										
		# $gateName = $inputs[0]; 		
		# printf("$name POF = %0.6f, Gain = %0.6f, Net Gain = %0.6f, Gate = ".($gateName.scalar @inputs-1)."\n", $probOfFailure{$name}*100, $Gain{$name}*100, $netGain{$name}*100);
		
		##########################################
		# Condition to PROTECT TMR VOTER ONLY
		##########################################
		# @row = split("-", $name);				
		# $currentGate = $row[0];				
		# if (($currentGate =~ m/_4$|_5$|_6$/) or (grep {$_ eq $currentGate} @primaryOutputs)) { 
		# if (($currentGate =~ m/_3$/) or (grep {$_ eq $currentGate} @primaryOutputs)) { #FOR DMR VOTER PROTECTION
			# push @sensitiveNodes, $name;								
		# }
		##########################################
		
		push @sensitiveNodes, $name;	
		# printf "Name: $name, NPOF=%0.4f, PPOF=%0.4f, Gain=%0.4f, OH = %0.2f\n",($probOfFailure_COPY{$name}*100), ($POF*100), ($Gain{$name}*100), $areaOH{$name};
		# printf "Name: $name, NPOF=%0.4f, Gain=%0.4f, AREA OH = %0.4f, NET GAIN = %0.4f\n",$probOfFailure_COPY{$name}, $Gain{$name}, $areaOH{$name}, $netGain{$name};		
	}		
	# print "Sen = @sensitiveNodes \n";
	# print "\n"; 
	# exit;
   
	$circuitArea = sprintf("%0.3f", $circuitArea);	
	# -----------------------------------------------#			
	
	open (LOG, ">$inputFile.$thValue.log") or die $!;
	print (LOG "************************************\n");  
	print (LOG "PROCESSING $inputFile ...\n\n");  
	printf (LOG "==>POF = %0.4f, Area = %0.4f, Total Nodes = %d, TH = %0.4f\n",$POF*100, $circuitArea, scalar @sensitiveNodes, $thValue*100);
	
	#************************************************************************
	#	Protection Code Starts from here
	#************************************************************************
	@allNodes = @{ dclone(\@sensitiveNodes) }; 
	%areaOH = ();
		
	$crg = "g212-P1";	
	$currentNode = shift(@sensitiveNodes);
	
	$flag = 0;
	$currentTh = shift(@ths);
	$currentNodePOF = 0;
	# $NGT = 0.1/100;
	
		
	while ($POF > $thValue) {										
	# while (-$netGain{$currentNode} >= $NGT) {										
		
		if (!(grep {$_ eq $currentNode} @sensitiveNodes)) {
			push @sensitiveNodes, $currentNode;
		}
					
		@row = split("-", $currentNode);				
		$currentGate = $row[0];
		$currentType = $row[1]; # i.e. nmos or pmos		
		@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.										
		$gateName = $inputs[0]; 			
		
		my @pNodes = getProcessedNodes($currentNode, $gateName,  scalar @inputs - 1);
		foreach $ll (@pNodes) {
			if (!(grep {$_ eq $ll} @processedNodes)) {
				push @processedNodes, $ll;	
			}
		}
		
		# print "processed nodes = @processedNodes \n"; $cin=getc(STDIN);
					
		if ($gateName eq "NAND") {
			$protectionType = getProtectionTypeNAND_NORMAL($protType{$currentGate}, $currentType, scalar @inputs - 1);						
		}
		elsif ($gateName eq "NOR") {
			$protectionType = getProtectionTypeNOR_NORMAL($protType{$currentGate}, $currentType, scalar @inputs - 1);		
		}		
		elsif ($gateName eq "NOT") {
			$protectionType = getProtectionTypeNOT($protType{$currentGate}, $currentType, scalar @inputs - 1);									
		}		
		
		# protecting the type e.g., NAND21, NAND32, NAND43 etc.
		$redundancyModel	=	$gateName.(scalar @inputs - 1).$protectionType;		 

		#Update Circuit Area
		$newArea = sprintf("%0.3f", $gateArea{$redundancyModel});
		$oldArea = sprintf("%0.3f", $currentCircuitGateAreas{$currentGate});
		$overHead = sprintf("%0.3f", $newArea - $oldArea);				
		$circuitArea += sprintf("%0.3f", $overHead);
		$protType{$currentGate} = $protectionType;			
		$currentCircuitGateAreas{$currentGate} +=  $overHead;
		$areaOH{$currentNode} = $overHead;
		$currentNodePOF = $probOfFailure{$currentNode};
		
		# if ($flag==1) {
			# print "CN: $currentNode, Gate Area = $currentCircuitGateAreas{$currentGate}, New AREA = $gateArea{$redundancyModel}, OH = $overHead, OA = $oldArea\n";
		# }
			
		@nodesToUpdate = ();
		if ($inputs[0] eq "NAND" or $inputs[0] eq "NOR") {
			
			for $kk (1..scalar @inputs -1) {
				push @nodesToUpdate, $currentGate."-N$kk";					
			}			
			for $kk (1..scalar @inputs -1) {
				push @nodesToUpdate, $currentGate."-P$kk";					
			}			
		}			
		elsif ($inputs[0] eq "NOT") {				
			push @nodesToUpdate, $currentGate."-N1";
			push @nodesToUpdate, $currentGate."-P1";						
		}
		
		# if ($currentNode eq "g212-P1") {
			# print "\n*******************************************************************************\n";
			# print "Protection Algorithm starting to protect $currentNode\n";
			# print "*******************************************************************************\n";
			# print "====>Current Node = $currentNode, POF = ".($probOfFailure{$currentNode}*100.", Area = $circuitArea, AREA OH = $areaOH{$currentNode}, Prev Area = ",($circuitArea-$overHead),", Prot Type = $protType{$currentGate}\n\n";		
		# } 
		
		# Iterate through the transistors list to update their POFs	
		foreach my $node (@allNodes) {

			@failedVectors = ();	

			@row = split("-", $node);				
			$CG = $row[0];
			$cType = $row[1]; # i.e. nmos or pmos	
									
			if (grep {$_ eq $node} @nodesToUpdate) {
				if ($protectionType == 20) { # FULLY PROTECTED CASE, make POFs of transistors of $currentGate to zero
					$probOfFailure{$node}	= 	0;	
					$detectionProb{$node} = 	0;
					$nodeAreas{$node} = $transArea{$redundancyModel."-$cType"};
				}
				else {
					$trans = $redundancyModel."-$cType";					
					
					for $vector ( keys %{ $tech{$trans} } ) {
						push @failedVectors, $vector;						
					}					
			
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$CG} } ) {
						push @currentFailedVectors, $vector;						
					}
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
													
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 
					}
					
					$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate}/$numberOfTestVectors);
					$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate}/$numberOfTestVectors);									
						
					$drainArea = $transArea{$trans};	
					$nodeAreas{$node} = $drainArea;
									
					$gateContProb = 0;
					$stuckAtProb = 0;
					
					if ($cType =~ m/N/i) {
						$gateContProb = $gateConts_1{$CG};
						$stuckAtProb = $sa0;
					}
					else {
						$gateContProb = $gateConts_0{$CG};
						$stuckAtProb = $sa1;
					}
					
					$detectionProb{$node}	=	($freq*$stuckAtProb)/$gateContProb;
					$strikeProb{$node} 	=	$drainArea/$circuitArea;
					$probOfFailure{$node}	= 	$detectionProb{$node}*$strikeProb{$node};					
				}
				# if (($currentNode eq "g212-P1" and $flag==1) or $verbosity ==1) {
					# print "Node = $node, protType = $protectionType,  CG = $currentGate, $trans Area = $drainArea, Total Area = $circuitArea\n";
					# print "Prob SA0 = $sa0, SA1 = $sa1, PC0 = $gateConts_0{$currentGate}, PC1 = $gateConts_1{$currentGate}, IPP = $currentCircuitPropFailureProbs{$node}\n";		
					# print "Failed Vecs. = @failedVectors\n";
					# print "Current IPP = @currentFailedVectors\nCommon = @isect\n";						
					# print "Node = $node: FREQ=$freq, DET = ",$detectionProb{$node}," HIT = ",$strikeProb{$node}," Trans-Area = $drainArea, POF $node = ",$probOfFailure{$node}*100,"\n\n";
				# }		
			}
			else {
				$drainArea = $nodeAreas{$node};				
				$strikeProb{$node} 	=	$drainArea/$circuitArea;					
				$probOfFailure{$node}	= 	$detectionProb{$node}*$strikeProb{$node};					
				
				# if ($currentNode eq "v" or $verbosity ==1) {
					# print "::Node = $node: DET = $detectionProb{$node}, HIT = $strikeProb{$node}, Trans-Area = $drainArea, POF $node = $probOfFailure{$node}\n";	
				# }
			}			
		}								
		###############################################################################
		$PP=0;
		foreach $kkl (@sensitiveNodes) {
			$PP += $probOfFailure{$kkl};
		}
		if ($flag==1) {
			printf "\n-->POF Ater Protecting $currentNode = %0.4f\n",$PP*100;	
			exit;
		}
		##############################################################
		#Re-Compute Gains 
		##############################################################	
		@nodes = sort(difference(@sensitiveNodes, @processedNodes)); 		
			
		@sensitiveNodes1 = sort(@{ dclone(\@sensitiveNodes) }); 
			 
		$crg = "g477-N1";
		
		# print "Gains Before Processing $currentNode....\n";
		# print "Recomputing gains after protecting $currentNode....\n";
		# print "Pr @processedNodes\n";
		# print Dumper \%Gain;
		# print "\n\n";
		# print Dumper \%protType;
		# print "Nodes to Update: @sensitiveNodes1\n";
		%probOfFailure_COPY = ();
		
		foreach my $currentNode1 (@nodes) {
		
			$probOfFailure_COPY{$currentNode1} = 0;
						
			%detectionProb_COPY = ();
			%strikeProb_COPY = ();					
			$protectionType1 = 0;	
						
			@row1 = split("-", $currentNode1);				
			$currentGate1 = $row1[0];
			$currentType1 = $row1[1]; # i.e. nmos or pmos		
			@inputs1 = split("-", $inputs{$currentGate1});	#inputs to the current gate.										
			$gateName1 = $inputs1[0]; 	

			if ($gateName1 eq "NAND") {
				$protectionType1 = getProtectionTypeNAND_NORMAL($protType{$currentGate1}, $currentType1, scalar @inputs1 - 1);			
			}
			elsif ($gateName1 eq "NOR") {
				$protectionType1 = getProtectionTypeNOR_NORMAL($protType{$currentGate1}, $currentType1, scalar @inputs1 - 1);		
			}		
			elsif ($gateName1 eq "NOT") {
				$protectionType1 = getProtectionTypeNOT($protType{$currentGate1}, $currentType1, scalar @inputs1 - 1);									
			}		
			
			# protecting the type e.g., NAND21, NAND32, NAND43 etc.			
			$redundancyModel1	=	$gateName1.(scalar @inputs1 - 1).$protectionType1;		 

			# print "$currentGate: R Model : $redundancyModel1, $currentGate1, $protType{$currentGate1}, $currentType1, $protectionType1\n";# $cin=getc(STDIN);
			# print "CN: $currentNode, SEN: @sensitiveNodes1\n"; #$cin=getc(STDIN);
						
			# $newArea1 = $gateArea{$redundancyModel1};			
			# $oldArea1 = $circuitArea;
			# $overHead1 = $newArea1 - $oldArea1;				
			# $circuitArea_T = $circuitArea+$overHead1;
			# $currentCircuitGateAreas1{$currentGate1} =  $newArea1;
			
			%nodeAreas1 =  %{ dclone(\%nodeAreas) };					
			@nodesToUpdate1 = ();
			if ($inputs1[0] eq "NAND" or $inputs1[0] eq "NOR") {
				for $kk (1..scalar @inputs1 -1) {
					$ccg = $currentGate1."-N$kk";
					$nodeAreas1{$ccg} = $transArea{$redundancyModel1."-N$kk"};
					push @nodesToUpdate1, $currentGate1."-N$kk";								
				}
				for $kk (1..scalar @inputs1 -1) {
					$ccg = $currentGate1."-P$kk";
					$nodeAreas1{$ccg} = $transArea{$redundancyModel1."-P$kk"};					
					push @nodesToUpdate1, $currentGate1."-P$kk";								
				}			
			}			
			elsif ($inputs1[0] eq "NOT") {	
				$ccg1 = $currentGate1."-N1";
				$ccg2 = $currentGate1."-P1";
				$nodeAreas1{$ccg1} = $transArea{$redundancyModel1."-N1"};
				$nodeAreas1{$ccg2} = $transArea{$redundancyModel1."-P1"};
				push @nodesToUpdate1, $currentGate1."-N1";
				push @nodesToUpdate1, $currentGate1."-P1";						
			}
			
			
			#Update Circuit Area
			$circuitArea_T = 0;
			# print "Protected Node: $currentNode, Recomputing Gain:$currentNode1, Ctype=$protType{$currentGate1}, NType = $protectionType1, R MODEL:$redundancyModel1\n"; $cin=getc(STDIN);
			foreach $value (keys %nodeAreas1) {
				$circuitArea_T += $nodeAreas1{$value};			
			}
			$circuitArea_T = sprintf("%0.3f", $circuitArea_T);
			
			$areaOH{$currentNode1} = sprintf("%0.3f", $circuitArea_T - $circuitArea);
			if ($areaOH{$currentNode1}==0) {
				$areaOH{$currentNode1} = 1;
			}
			
			# if (($currentNode1 eq "g448-N3" and $flag==1) or $verbosity ==1) {
				# print "\nSTART OF EVALUATION $currentNode1*******************************************************\n\n";
				# print "====>Current Node = $currentNode1, POF = ",$probOfFailure{$currentNode1}*100,"\n"; 
				# print "Gate Name = $gateName1, # of Inputs = ",(scalar @inputs1 - 1)," Circuit Area: AP = $circuitArea_T, BP = $circuitArea, OH = $areaOH{$currentNode1}\n";	
				# print "Prot Type = $protectionType1, Current Prot = $protType{$currentGate1}, R Model = $redundancyModel1\n\n";					
			# } 
			
			$remPOF = 0;
			$cgPOF = 0;
			# Iterate through the transistors list to update their POFs	
			foreach my $node1 (@sensitiveNodes1) {
			
				@failedVectors1 = ();					
				
				@row1 = split("-", $node1);				
				$CG1 = $row1[0];
				$cType1 = $row1[1]; # i.e. nmos or pmos	
				# @in = split("-", $inputs{$CG1});	#inputs to the current gate.										
							
				if (grep {$_ eq $node1} @nodesToUpdate1) {
					if ($protectionType1 == 20) { # FULLY PROTECTED CASE, make POFs of transistors of $currentGate to zero
						$probOfFailure_COPY{$node1}	+= 	0;	
						$detectionProb_COPY{$node1} 	= 	0;						
					}
					else {
						$trans1 = $redundancyModel1."-$cType1";					
						
						for $vector ( keys %{ $tech{$trans1} } ) {
							push @failedVectors1, $vector;						
						}					
				
						# Read the failed vectors for current gate in the current circuit
						@currentFailedVectors1 = ();
						for $vector ( keys %{ $ipp{$CG1} } ) {
							push @currentFailedVectors1, $vector;						
						}
						
						@isect1 = intersect(@failedVectors1, @currentFailedVectors1);
														
						$freq1=0;
						foreach $value (@isect1) {							
							$freq1 += $ipp{$currentGate1}{$value}; 
						}
						
						$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate1}/$numberOfTestVectors);
						$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate1}/$numberOfTestVectors);									
							
						$drainArea1 = $transArea{$trans1};			
						
						# print "$node: TRANS = $trans DA = $drainArea, CN = $currentNode, P = $protectionType\n"; $cin=getc(STDIN);
										
						$gateContProb1 = 0;
						$stuckAtProb1 = 0;
						
						if ($cType1 =~ m/N/i) {
							$gateContProb1 = $gateConts_1{$CG1};
							$stuckAtProb1 = $sa0;
						}
						else {
							$gateContProb1 = $gateConts_0{$CG1};
							$stuckAtProb1 = $sa1;
						}
						
						$detectionProb_COPY{$node1}	=	($freq1*$stuckAtProb1)/$gateContProb1;
						$strikeProb_COPY{$node1} 		=	$drainArea1/$circuitArea_T;				
						$probOfFailure_TRANS{$node1}		= 	$detectionProb_COPY{$node1}*$strikeProb_COPY{$node1};
											
						$probOfFailure_COPY{$currentNode1}		+= 	$detectionProb_COPY{$node1}*$strikeProb_COPY{$node1};
						$cgPOF += $probOfFailure_TRANS{$node1};
											
						# if ($currentNode1 eq "g448-N3" and $flag==1 or $verbosity ==1) {
							# print "Node = $node1, protType = $protectionType1,  CG = $currentGate1, $trans1 Area = $drainArea1, Total Area = $circuitArea_T\n";
							# print "Prob SA0 = $sa0, SA1 = $sa1, PC0 = $gateConts_0{$currentGate1}, PC1 = $gateConts_1{$currentGate1}, IPP = $currentCircuitPropFailureProbs{$node1}\n";		
							# print "Failed Vecs. = @failedVectors1\n";
							# print "Current IPP = @currentFailedVectors1\nCommon = @isect1\n";
							# print ":::Node = $node1, FREQ=$freq1, DET = ",$detectionProb_COPY{$node1}," HIT = ",$strikeProb_COPY{$node1},", Trans-Area = $drainArea1, POF $node1 = ",$probOfFailure_TRANS{$node1}*100,"\n\n";
						# }		
					}
				}
				else {
					$drainArea1 = $nodeAreas1{$node1};
					
					$strikeProb_COPY{$node1} 	=	$drainArea1/$circuitArea_T;
					$probOfFailure_TRANS{$node1}		= 	$detectionProb{$node1}*$strikeProb_COPY{$node1};
					$probOfFailure_COPY{$currentNode1}	+= 	$detectionProb{$node1}*$strikeProb_COPY{$node1};
										
					$remPOF += $probOfFailure_TRANS{$node1};
					
					# if ($currentNode1 eq "g448-P1" and $flag==1 or $verbosity ==1) {
						# print "Node: $node1: DET = $detectionProb{$node1}, HIT = $strikeProb_COPY{$node1}, Trans-Area = $drainArea1, POF-$node1=",$probOfFailure_TRANS{$node1}*100,"\n"; 
					# }
				}												
			}
			# if ($currentNode1 eq "g448-N3" and $flag==1 or $verbosity ==1) {
				# print "=>POF After protecting $currentNode1 = ",$probOfFailure_COPY{$currentNode1}*100," AREA OH = $areaOH{$currentNode1}, Gain = ",($probOfFailure_COPY{$currentNode1}-$PP)*100,", NET GAIN = ",(($probOfFailure_COPY{$currentNode1}-$PP)/$areaOH{$currentNode1})*100,", PP = ",$PP*100," CURRENT_GATE-POF=",$cgPOF*100,",  REMAINING_GATES-POF=",$remPOF*100,"\n\n";
				# print "=========================================================END OF EVALUATION $currentNode1\n\n";
			# }
		}			
		#############################################################
		
		$NEWPOF = 0;
		foreach my $name (@allNodes) {				
			$NEWPOF += $probOfFailure{$name};										
		}	 	
		
		%netGain = ();		 
		foreach my $name (@allNodes) {	
			if (grep {$_ eq $name} @processedNodes) {				
				next;
			}
			else {	
				if ($areaOH{$name}==0) {
					$areaOH{$name} = 1;
				}
				$netGain{$name} = (($probOfFailure_COPY{$name} - $NEWPOF))/$areaOH{$name};
				$Gain{$name} = ($probOfFailure_COPY{$name} - $NEWPOF);
			}
		}			
		
		# print "Processed Nodes: @processedNodes\n";
		# print "\nNEW POFs After Processing $currentNode....\n";
		# print Dumper \%probOfFailure_COPY;				
		# print "\nGains After Processing $currentNode....\n";
		# print Dumper \%Gain;
		# print "\n\n"; 
		# print Dumper \%areaOH;	
		
		if ($areaOH{$currentNode}==0) {
			$areaOH{$currentNode} = 1;
		}
					
		# printf (LOG "POF = %0.6f\n", $NEWPOF*100);			
		
		printf (LOG ">CIRC POF=%0.4f, Area=%.4f, CN=$currentNode, Orig. POF=%0.6f, POF= %0.6f, G= %0.4f, NG= %0.4f, PT=$protType{$currentGate}, OH=$areaOH{$currentNode}, GN=".($gateName.scalar @inputs-1)."\n", $NEWPOF*100, $circuitArea, ($POF_ORIGINAL{$currentNode}*100), ($currentNodePOF*100), (($NEWPOF-$POF)*100), (($NEWPOF-$POF)/$areaOH{$currentNode})*100);
		
		# printf (LOG ">CIRC POF=%0.4f, Area=%.4f, CN=$currentNode, Orig. POF=%0.6f, POF= %0.6f, G= %0.4f, NG= %0.4f, PT=$protType{$currentGate}, OH=$areaOH{$currentNode}, GN=".($gateName.scalar @inputs-1)."\n", $NEWPOF*100, $circuitArea, ($POF_ORIGINAL{$currentNode}*100), ($currentNodePOF*100), ($Gain{$currentNode}*100), ($netGain{$currentNode}*100) );	
		
		printf (">POF=%0.4f, Area=%.4f, Gain=%0.4f, Net Gain=  %0.4f, CN=$currentNode,PT=$protType{$currentGate}, OH=$areaOH{$currentNode}, GN=".($gateName.scalar @inputs-1)."\n\n", $NEWPOF*100, $circuitArea, (($NEWPOF-$POF)*100), (($NEWPOF-$POF)/$areaOH{$currentNode})*100);	
				
		@temp = ();
		foreach my $name (sort { $netGain{$a} <=> $netGain{$b} or $a cmp $b } keys %netGain) {
			push @temp, $name;	
			# print "$name: NPOF = ",$probOfFailure_COPY{$name}*100," Gain = ",$Gain{$name}*100," NET GAIN = ",$netGain{$name}*100,"\n";
		}		
		$currentNode = shift(@temp);						
		$POF = $NEWPOF;
		
		# printf(LOG ">NNG = %0.6f\n", $netGain{$currentNode}*100);
		# if ($currentNode eq "g212-P1") {
			# $flag=1;
			# print "Next node = $currentNode, Gain = ",$Gain{$currentNode}*100," NET GAIN = ",$netGain{$currentNode}*100,"\n\n\n"; 					
		# }
	  
		###################################################################################
	
		# $POF = 0;
		# foreach my $name (@allNodes) {		
		# $POF += $probOfFailure{$name};					
		# } 
		# printf LOG "\nFinal POF = %0.4f\n", $POF*100;
		
		if ( ($POF <= $currentTh) ) { 
		# if ( -$netGain{$currentNode} <= $NGT ) {	
	
			#------------------------------------------------------	
			#	Writing the final bench file by iterating through
			#	all the gates and based on their nType and pType
			#	variable values, apply suitable protection.
			#------------------------------------------------------	
			
			$newBenchFile = $inputFile."R_".$currentTh.".bench";	
			open (OUTPUT_Bench, ">$newBenchFile") or die $!;
			print OUTPUT_Bench "#Protection with Threshold of  ".((1-$currentTh)*100)."%\n";
			print OUTPUT_Bench "\n";
			print OUTPUT_Bench @IOs;
			print OUTPUT_Bench "\n";
			
			foreach $currentGate (@orderedGates) {
			
				@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.			
				$gateName = $inputs[0]; 	 
				
				if (($protType{$currentGate} == 20 )) { # or (grep {$_ eq $currentGate} @primaryOutputs)) {						
					print OUTPUT_Bench "$currentGate = D".$gateName."(";							
					for ($ii = 1; $ii < scalar @inputs; $ii++) {					
						if ($ii  == scalar @inputs - 1)	
						{	print OUTPUT_Bench "$inputs[$ii])\n";	}
						else
						{	print OUTPUT_Bench "$inputs[$ii], ";	}											
					}											
				}
				elsif (($protType{$currentGate} > 0 and $protType{$currentGate} < 9)) {
					print OUTPUT_Bench "$currentGate = $inputs[0]".(scalar @inputs -1)."$protType{$currentGate}(";								
					for ($ii = 1; $ii < scalar @inputs; $ii++) {					
						if ($ii  == scalar @inputs -1) {
							print OUTPUT_Bench "$inputs[$ii])\n";	
						}
						else {
							print OUTPUT_Bench "$inputs[$ii], ";	
						}
					}					
				}		
				elsif ($protType{$currentGate} == 0 ) { 
					print OUTPUT_Bench "$currentGate = $gateName(";							
					for ($ii = 1; $ii < scalar @inputs; $ii++) {					
						if ($ii  == scalar @inputs - 1)	
						{	print OUTPUT_Bench "$inputs[$ii])\n";	}
						else
						{	print OUTPUT_Bench "$inputs[$ii], ";	}											
					}											
				}		
				else {
					print OUTPUT_Bench $_;	
				}	
				
				if (grep $_ eq $currentGate, @primaryOutputs) {
				print OUTPUT_Bench "\n";
				}
			}
			
			print OUTPUT_Bench "END\n";
			close(OUTPUT_Bench);	
			#-------------------------------------------------------------
			
			$currentTh = shift(@ths);
		}
	}
	
	my $run_time = Time::HiRes::tv_interval($start_time);
	print "\tTime taken to create Bench File = $run_time sec.\n";	
	print LOG "\n\tTime taken = $run_time sec.\n";	
	
	close(LOG);
}
#######################################################

sub selectionAlgorithmWithPOFSUpdate_GREEDY_AREACONSTRAINT {
	
	my $areaOH = $_[0];
			
	my @orderedGates = ();
	my @sensitiveNodes = ();
	my @processedNodes = ();
	my @IOs = ();
	my %outBenchFile = ();
	my %probOfFailure = ();
	my %probOfFailure_COPY = ();
	my %detectionProb = ();
	my %strikeProb = ();
	my %protType = ();	
	my %gateConts_0 = ();
	my %gateConts_1 = ();
	my %currentCircuitGateAreas = ();	
	my %nodeAreas = ();
	my $currentArea = 0;
	my $currentNT = 0;
	my $targetArea = 0;
	
	my $verbosity = 0;
		
	%ipp = %{retrieve($inputFile.'.ipp')};
	%tech = %{retrieve('130nm.pf')};
		
	
	my $start_time = [Time::HiRes::gettimeofday()];	
	
	$nmosDrainArea = 0.09;
	$pmosDrainArea = 0.18;
	
	################################################
	# Get Area of current Circuit
	################################################
	system ("perl bench_to_spice_45nm.pl $inputFile 1");
	open(IN,"area.sp") || die " Cannot open input file area.sp \n";
	$circuitArea=0;	# area of circuit
	while(<IN>){
		$circuitArea = $_;
	}
	close(IN);
	system ("del area.sp");
	system ("del $inputFile.sp");
	
	# $circuitArea = 42.12;
	# $circuitArea = 338.31;
	# $circuitArea = 1047.33;
	
	# $circuitArea = 1.08;
	# $circuitArea = 3.150;
	
	#############################################################
	#	Read the Propagation Stats file of current circuit.		#
	#############################################################
	my %currentCircuitPropFailureProbs = ();
	$propFile = $inputFile.".prop";
	
	open (PROP_IN, $propFile) or die $!;
	while(<PROP_IN>) {
		chomp;
		@row = split('=>', $_);
		$currentCircuitPropFailureProbs{$row[0]} = $row[1];		
	}
	close(PROP_IN);	
	#############################################################
	
	#---------------------------------------------------#
	#	Save each gate in the circuit along with 		#
	#   the prob. of failure of each transistor			# 
	#	in HASH structure. 								#
	#---------------------------------------------------#
	open (INPUT_FILE, $benchFile) or die $!;	
	while (<INPUT_FILE>) {	
		if (/=/) {				
			my @gateList = split(" = ", $_);
			$gateList[1] = "= ".$gateList[1];			
						
			$currentGate = $gateList[0];				
			$outBenchFile{$currentGate} = $gateList[1];		
			push @orderedGates, $currentGate;
			
			$protType{$currentGate} = 0; #Initialize the protection type of each senstive gate to 0			
			
			#-----------------------------------------------------------#
			#	Compute Probability of failure of each transistor of	#
			#	the current selected gate.								#
			#-----------------------------------------------------------#
			
			#-------------------------------------------------
			#Generate the remaining parts of final bench file
			#-------------------------------------------------			
			@gateList = ($_ =~ m/(\w+)/g);				
			$gateName[0] = $gateList[1];			
			@gateList = ($gateList[0], @gateList[2..$#gateList]);		

			$currentGate = $gateList[0];	
			@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.	
			$gateName = $inputs[0]; 	
			
			$currentCircuitGateAreas{$currentGate} = $gateArea{$gateName.(scalar @inputs-1)};
			
			my $errorType = -1;
			my $gateType = ();
						
			$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate}/$numberOfTestVectors);
			$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate}/$numberOfTestVectors);			
								
			# process the Gates			
			my $nType = 0;
			my $pType = 0;
			my $nmos = 0;
			my $pmos = 0;			
				
			#iterate through all the N-type and P-Type transistors.
			for ($ii = 1; $ii < scalar @inputs; $ii++) {
				$nmos = "N".$ii;
				$pmos = "P".$ii;					
				
				#Compute gate controllability from the .ipp file, only once for each gate
				if ($ii==1) {
				
					#FOR NMOS
					# Read the generic failed vectors for N1
					@failedVectors = ();
					$nmos1 = $gateName.(scalar @inputs - 1)."-N$ii";						
					
					for $vector ( keys %{ $tech{$nmos1} } ) {
						push @failedVectors, $vector;						
					}										
				
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$currentGate} } ) {
						push @currentFailedVectors, $vector;						
					}
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
					
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 							
					}
					$gateConts_1{$currentGate} = $freq;
						
					#FOR PMOS
					# Read the generic failed vectors for P-Type
					@failedVectors = ();	
					$pmos1 = $gateName.(scalar @inputs - 1)."-P$ii";	
										
					for $vector ( keys %{ $tech{$pmos1} } ) {
						push @failedVectors, $vector;						
					}					
					
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$currentGate} } ) {
						push @currentFailedVectors, $vector;						
					}				
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
				
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 
					}
					$gateConts_0{$currentGate} = $freq;
					
					if ($gateConts_1{$currentGate}==0) {	$gateConts_1{$currentGate} = 1;	}
					if ($gateConts_0{$currentGate}==0) {	$gateConts_0{$currentGate} = 1;	}					
				}				
								
				$currentNode_N = $currentGate."-$nmos";
				$currentNode_P = $currentGate."-$pmos";
				
				if ($currentCircuitPropFailureProbs{$currentNode_N}*$sa0 > 0) {
					$detectionProb{$currentNode_N}	=	$currentCircuitPropFailureProbs{$currentNode_N}*$sa0/$gateConts_1{$currentGate};
					$strikeProb{$currentNode_N} 	=	$nmosDrainArea/$circuitArea;
					$nodeAreas{$currentNode_N} = $nmosDrainArea;
					$probOfFailure{$currentNode_N}	= 	$detectionProb{$currentNode_N}*$strikeProb{$currentNode_N};					
				}
				else {
					$detectionProb{$currentNode_N}	= 0;					
					$probOfFailure{$currentNode_N} = 0;						
					$nodeAreas{$currentNode_N} = $nmosDrainArea;
				}
								
				if ($currentCircuitPropFailureProbs{$currentNode_P}*$sa1 > 0) {
					$detectionProb{$currentNode_P}	=	$currentCircuitPropFailureProbs{$currentNode_P}*$sa1/$gateConts_0{$currentGate};
					$strikeProb{$currentNode_P} 	=	$pmosDrainArea/$circuitArea;
					$nodeAreas{$currentNode_P} = $pmosDrainArea;
					$probOfFailure{$currentNode_P}	= 	$detectionProb{$currentNode_P}*$strikeProb{$currentNode_P};					
				}
				else {
					$detectionProb{$currentNode_P}	= 0;
					$probOfFailure{$currentNode_P}  = 0;
					$nodeAreas{$currentNode_P} = $pmosDrainArea;
				}															
			}					
		}		
		elsif ($_ =~ /INPUT|OUTPUT/) {
			push @IOs, $_;
		}
	} #End of Main while loop
	close(INPUT_FILE);
	
	#Sort the gates according to their prob. of failure detection	
	foreach my $name (sort { $probOfFailure{$b} <=> $probOfFailure{$a} or $a cmp $b } keys %probOfFailure) {					
		push @sensitiveNodes, $name;	
		# print "Name: $name\n";
	}	
	$totalNodes = scalar @sensitiveNodes;
	
	$POF = 0;	
	foreach my $name (@sensitiveNodes) {			
		$POF += $probOfFailure{$name};				
	}
	
	printf "==>Initial POF = %0.4f, Area = $circuitArea, OH = %0.4f, Total Nodes = $totalNodes\n", $POF*100, $areaOH*100;	
		
	##############################################################
	#Compute Gains of each protection
	##############################################################	
	@allNodes = @{ dclone(\@sensitiveNodes) }; 
	%areaOH = ();	
	foreach my $currentNode (@sensitiveNodes) {
	
		%detectionProb_COPY = ();
		%strikeProb_COPY = ();
		$protectionType = 0;	
		$circuitArea_T = 0;
		
		@row = split("-", $currentNode);				
		$currentGate = $row[0];
		$currentType = $row[1]; # i.e. nmos or pmos		
		@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.										
		$gateName = $inputs[0]; 	
				
		if ($gateName eq "NAND") {
			$protectionType = getProtectionTypeNAND_NORMAL($protType{$currentGate}, $currentType, (scalar @inputs - 1));			
		}
		elsif ($gateName eq "NOR") {
			$protectionType = getProtectionTypeNOR_NORMAL($protType{$currentGate}, $currentType, (scalar @inputs - 1));		
		}		
		elsif ($gateName eq "NOT") {
			$protectionType = getProtectionTypeNOT($protType{$currentGate}, $currentType, (scalar @inputs - 1));									
		}		
		
		# protecting the type e.g., NAND21, NAND32, NAND43 etc.
		$redundancyModel	=	$gateName.(scalar @inputs - 1).$protectionType;		 

		#Update Circuit Area
		$newArea = $gateArea{$redundancyModel};
		$oldArea = $currentCircuitGateAreas{$currentGate};
		$overHead = $newArea - $oldArea;				
		$circuitArea_T = $circuitArea+$overHead;
		$areaOH{$currentNode} = $circuitArea_T-$circuitArea; 
		
		@nodesToUpdate = ();
		if ($inputs[0] eq "NAND" or $inputs[0] eq "NOR") {
			for $kk (1..scalar @inputs -1) {
				push @nodesToUpdate, $currentGate."-N$kk";		
			}
			for $kk (1..scalar @inputs -1) {
				push @nodesToUpdate, $currentGate."-P$kk";			
			}			
		}			
		elsif ($inputs[0] eq "NOT") {				
			push @nodesToUpdate, $currentGate."-N1";
			push @nodesToUpdate, $currentGate."-P1";						
		}		
		
		# Iterate through the transistors list to update their POFs	if protection is applied on current nodes.
		foreach my $node (@allNodes) {
		
			@failedVectors = ();	

			@row = split("-", $node);				
			$CG = $row[0];
			$cType = $row[1]; # i.e. nmos or pmos	
									
			if (grep {$_ eq $node} @nodesToUpdate) {
				$trans = $redundancyModel."-$cType";					
				
				for $vector ( keys %{ $tech{$trans} } ) {
					push @failedVectors, $vector;						
				}					
		
				# Read the failed vectors for current gate in the current circuit
				@currentFailedVectors = ();
				for $vector ( keys %{ $ipp{$CG} } ) {
					push @currentFailedVectors, $vector;						
				}
				
				@isect = intersect(@failedVectors, @currentFailedVectors);
												
				$freq=0;
				foreach $value (@isect) {							
					$freq += $ipp{$currentGate}{$value}; 
				}
				
				$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate}/$numberOfTestVectors);
				$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate}/$numberOfTestVectors);									
					
				$drainArea = $transArea{$trans};			
															
				$gateContProb = 0;
				$stuckAtProb = 0;
				
				if ($cType =~ m/N/i) {
					$gateContProb = $gateConts_1{$CG};
					$stuckAtProb = $sa0;
				}
				else {
					$gateContProb = $gateConts_0{$CG};
					$stuckAtProb = $sa1;
				}
				
				$detectionProb_COPY{$node}				=	$freq*$stuckAtProb/$gateContProb;
				$strikeProb_COPY{$node} 				=	$drainArea/$circuitArea_T;				
				$probOfFailure_TRANS{$node}				= 	$detectionProb_COPY{$node}*$strikeProb_COPY{$node};				
				$probOfFailure_COPY{$currentNode}		+= 	$detectionProb_COPY{$node}*$strikeProb_COPY{$node};				
			}
			else { #For these transistors only the detection probability is changed.
				if ($cType =~ m/N/i) {
					$drainArea = $nmosDrainArea;
				}
				else {
					$drainArea = $pmosDrainArea;
				}
				
				$strikeProb_COPY{$node} 			=	$drainArea/$circuitArea_T;			
				$probOfFailure_TRANS{$node}			= 	$detectionProb{$node}*$strikeProb_COPY{$node}; 
				$probOfFailure_COPY{$currentNode}	+= 	$detectionProb{$node}*$strikeProb_COPY{$node}; 			
			}												
		}		
	}			
	#############################################################

	%Gain = ();
	%netGain = ();
	foreach my $name (@sensitiveNodes) {			
		$Gain{$name} = $probOfFailure_COPY{$name} - $POF;	
		$netGain{$name} = $Gain{$name}/$areaOH{$name};	
	}	
	
	@sensitiveNodes = ();
	 foreach my $name (sort { $netGain{$a} <=> $netGain{$b} or $a cmp $b } keys %netGain) {	
		push @sensitiveNodes, $name;									
	}

						
	$circuitArea = sprintf("%0.3f", $circuitArea);
	$targetArea = $circuitArea + ($circuitArea*$areaOH);
		
	# -----------------------------------------------#			
	
	open (LOG, ">$inputFile.$areaOH.log") or die $!;
	print (LOG "************************************\n");  
	print (LOG "PROCESSING $inputFile ...\n\n");  
	printf (LOG "==>POF = %0.4f, Area = %0.4f, Total Nodes = %d, TH = %0.4f\n",$POF*100, $circuitArea, scalar @sensitiveNodes, $areaOH*100);
	
	#************************************************************************
	#	Protection Code Starts from here
	#************************************************************************
	@allNodes = @{ dclone(\@sensitiveNodes) }; 
	%areaOH = ();
		
	$crg = "g477";	
	$currentNode = shift(@sensitiveNodes);
	
	$flag = 0;
	# $currentTh = shift(@ths);
			
	while ($circuitArea <=  $targetArea) {										
		
		if (!(grep {$_ eq $currentNode} @sensitiveNodes)) {
			push @sensitiveNodes, $currentNode;
		}
			
		
		@row = split("-", $currentNode);				
		$currentGate = $row[0];
		$currentType = $row[1]; # i.e. nmos or pmos		
		@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.										
		$gateName = $inputs[0]; 			
		
		my @pNodes = getProcessedNodes($currentNode, $gateName,  scalar @inputs - 1);
		foreach $ll (@pNodes) {
			if (!(grep {$_ eq $ll} @processedNodes)) {
				push @processedNodes, $ll;	
			}
		}
									
		if ($gateName eq "NAND") {
			$protectionType = getProtectionTypeNAND_NORMAL($protType{$currentGate}, $currentType, scalar @inputs - 1);						
		}
		elsif ($gateName eq "NOR") {
			$protectionType = getProtectionTypeNOR_NORMAL($protType{$currentGate}, $currentType, scalar @inputs - 1);		
		}		
		elsif ($gateName eq "NOT") {
			$protectionType = getProtectionTypeNOT($protType{$currentGate}, $currentType, scalar @inputs - 1);									
		}		
		
		# protecting the type e.g., NAND21, NAND32, NAND43 etc.
		$redundancyModel	=	$gateName.(scalar @inputs - 1).$protectionType;		 

		#Update Circuit Area
		$newArea = sprintf("%0.3f", $gateArea{$redundancyModel});
		$oldArea = sprintf("%0.3f", $currentCircuitGateAreas{$currentGate});
		$overHead = sprintf("%0.3f", $newArea - $oldArea);				
		$circuitArea += sprintf("%0.3f", $overHead);
		$protType{$currentGate} = $protectionType;			
		$currentCircuitGateAreas{$currentGate} +=  $overHead;
		$areaOH{$currentNode} = $overHead;
					
		@nodesToUpdate = ();
		if ($inputs[0] eq "NAND" or $inputs[0] eq "NOR") {
			
			for $kk (1..scalar @inputs -1) {
				push @nodesToUpdate, $currentGate."-N$kk";					
			}			
			for $kk (1..scalar @inputs -1) {
				push @nodesToUpdate, $currentGate."-P$kk";					
			}			
		}			
		elsif ($inputs[0] eq "NOT") {				
			push @nodesToUpdate, $currentGate."-N1";
			push @nodesToUpdate, $currentGate."-P1";						
		}	
		
		# Iterate through the transistors list to update their POFs	
		foreach my $node (@allNodes) {

			@failedVectors = ();	

			@row = split("-", $node);				
			$CG = $row[0];
			$cType = $row[1]; # i.e. nmos or pmos	
									
			if (grep {$_ eq $node} @nodesToUpdate) {
				if ($protectionType == 20) { # FULLY PROTECTED CASE, make POFs of transistors of $currentGate to zero
					$probOfFailure{$node}	= 	0;	
					$detectionProb{$node} = 	0;
					$nodeAreas{$node} = $transArea{$redundancyModel."-$cType"};
				}
				else {
					$trans = $redundancyModel."-$cType";					
					
					for $vector ( keys %{ $tech{$trans} } ) {
						push @failedVectors, $vector;						
					}					
			
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$CG} } ) {
						push @currentFailedVectors, $vector;						
					}
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
													
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 
					}
					
					$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate}/$numberOfTestVectors);
					$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate}/$numberOfTestVectors);									
						
					$drainArea = $transArea{$trans};	
					$nodeAreas{$node} = $drainArea;
									
					$gateContProb = 0;
					$stuckAtProb = 0;
					
					if ($cType =~ m/N/i) {
						$gateContProb = $gateConts_1{$CG};
						$stuckAtProb = $sa0;
					}
					else {
						$gateContProb = $gateConts_0{$CG};
						$stuckAtProb = $sa1;
					}
					
					$detectionProb{$node}	=	($freq*$stuckAtProb)/$gateContProb;
					$strikeProb{$node} 	=	$drainArea/$circuitArea;
					$probOfFailure{$node}	= 	$detectionProb{$node}*$strikeProb{$node};					
				}					
			}
			else {
				$drainArea = $nodeAreas{$node};				
				$strikeProb{$node} 	=	$drainArea/$circuitArea;					
				$probOfFailure{$node}	= 	$detectionProb{$node}*$strikeProb{$node};								
			}			
		}								
		###############################################################################
		$PP=0;
		foreach $kkl (@sensitiveNodes) {
			$PP += $probOfFailure{$kkl};
		}		
		
		##############################################################
		#Re-Compute Gains 
		##############################################################	
		@nodes = sort(difference(@sensitiveNodes, @processedNodes)); 		
			
		@sensitiveNodes1 = sort(@{ dclone(\@sensitiveNodes) }); 
		%probOfFailure_COPY = ();
		
		foreach my $currentNode1 (@nodes) {
		
			$probOfFailure_COPY{$currentNode1} = 0;
						
			%detectionProb_COPY = ();
			%strikeProb_COPY = ();					
			$protectionType1 = 0;	
						
			@row1 = split("-", $currentNode1);				
			$currentGate1 = $row1[0];
			$currentType1 = $row1[1]; # i.e. nmos or pmos		
			@inputs1 = split("-", $inputs{$currentGate1});	#inputs to the current gate.										
			$gateName1 = $inputs1[0]; 	

			if ($gateName1 eq "NAND") {
				$protectionType1 = getProtectionTypeNAND_NORMAL($protType{$currentGate1}, $currentType1, scalar @inputs1 - 1);			
			}
			elsif ($gateName1 eq "NOR") {
				$protectionType1 = getProtectionTypeNOR_NORMAL($protType{$currentGate1}, $currentType1, scalar @inputs1 - 1);		
			}		
			elsif ($gateName1 eq "NOT") {
				$protectionType1 = getProtectionTypeNOT($protType{$currentGate1}, $currentType1, scalar @inputs1 - 1);									
			}		
			
			# protecting the type e.g., NAND21, NAND32, NAND43 etc.			
			$redundancyModel1	=	$gateName1.(scalar @inputs1 - 1).$protectionType1;		 
	
			%nodeAreas1 =  %{ dclone(\%nodeAreas) };					
			@nodesToUpdate1 = ();
			if ($inputs1[0] eq "NAND" or $inputs1[0] eq "NOR") {
				for $kk (1..scalar @inputs1 -1) {
					$ccg = $currentGate1."-N$kk";
					$nodeAreas1{$ccg} = $transArea{$redundancyModel1."-N$kk"};
					push @nodesToUpdate1, $currentGate1."-N$kk";								
				}
				for $kk (1..scalar @inputs1 -1) {
					$ccg = $currentGate1."-P$kk";
					$nodeAreas1{$ccg} = $transArea{$redundancyModel1."-P$kk"};					
					push @nodesToUpdate1, $currentGate1."-P$kk";								
				}			
			}			
			elsif ($inputs1[0] eq "NOT") {	
				$ccg1 = $currentGate1."-N1";
				$ccg2 = $currentGate1."-P1";
				$nodeAreas1{$ccg1} = $transArea{$redundancyModel1."-N1"};
				$nodeAreas1{$ccg2} = $transArea{$redundancyModel1."-P1"};
				push @nodesToUpdate1, $currentGate1."-N1";
				push @nodesToUpdate1, $currentGate1."-P1";						
			}
			
			
			#Update Circuit Area
			$circuitArea_T = 0;		
			foreach $value (keys %nodeAreas1) {
				$circuitArea_T += $nodeAreas1{$value};			
			}
			$circuitArea_T = sprintf("%0.3f", $circuitArea_T);
			
			$areaOH{$currentNode1} = sprintf("%0.3f", $circuitArea_T - $circuitArea);
			if ($areaOH{$currentNode1}==0) {
				$areaOH{$currentNode1} = 1;
			}
			
			$remPOF = 0;
			$cgPOF = 0;
			# Iterate through the transistors list to update their POFs	
			foreach my $node1 (@sensitiveNodes1) {
			
				@failedVectors1 = ();					
				
				@row1 = split("-", $node1);				
				$CG1 = $row1[0];
				$cType1 = $row1[1]; # i.e. nmos or pmos	
				# @in = split("-", $inputs{$CG1});	#inputs to the current gate.										
							
				if (grep {$_ eq $node1} @nodesToUpdate1) {
					if ($protectionType1 == 20) { # FULLY PROTECTED CASE, make POFs of transistors of $currentGate to zero
						$probOfFailure_COPY{$node1}	+= 	0;	
						$detectionProb_COPY{$node1} 	= 	0;						
					}
					else {
						$trans1 = $redundancyModel1."-$cType1";					
						
						for $vector ( keys %{ $tech{$trans1} } ) {
							push @failedVectors1, $vector;						
						}					
				
						# Read the failed vectors for current gate in the current circuit
						@currentFailedVectors1 = ();
						for $vector ( keys %{ $ipp{$CG1} } ) {
							push @currentFailedVectors1, $vector;						
						}
						
						@isect1 = intersect(@failedVectors1, @currentFailedVectors1);
														
						$freq1=0;
						foreach $value (@isect1) {							
							$freq1 += $ipp{$currentGate1}{$value}; 
						}
						
						$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate1}/$numberOfTestVectors);
						$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate1}/$numberOfTestVectors);									
							
						$drainArea1 = $transArea{$trans1};			
						$gateContProb1 = 0;
						$stuckAtProb1 = 0;
						
						if ($cType1 =~ m/N/i) {
							$gateContProb1 = $gateConts_1{$CG1};
							$stuckAtProb1 = $sa0;
						}
						else {
							$gateContProb1 = $gateConts_0{$CG1};
							$stuckAtProb1 = $sa1;
						}
						
						$detectionProb_COPY{$node1}	=	($freq1*$stuckAtProb1)/$gateContProb1;
						$strikeProb_COPY{$node1} 		=	$drainArea1/$circuitArea_T;				
						$probOfFailure_TRANS{$node1}		= 	$detectionProb_COPY{$node1}*$strikeProb_COPY{$node1};
											
						$probOfFailure_COPY{$currentNode1}		+= 	$detectionProb_COPY{$node1}*$strikeProb_COPY{$node1};
						$cgPOF += $probOfFailure_TRANS{$node1};				
					}
				}
				else {
					$drainArea1 = $nodeAreas1{$node1};
					
					$strikeProb_COPY{$node1} 	=	$drainArea1/$circuitArea_T;
					$probOfFailure_TRANS{$node1}		= 	$detectionProb{$node1}*$strikeProb_COPY{$node1};
					$probOfFailure_COPY{$currentNode1}	+= 	$detectionProb{$node1}*$strikeProb_COPY{$node1};
										
					$remPOF += $probOfFailure_TRANS{$node1};					
				}												
			}			
		}			
		#############################################################
		
		$NEWPOF = 0;
		foreach my $name (@allNodes) {				
			$NEWPOF += $probOfFailure{$name};										
		}	 	
		
		%netGain = ();		 
		foreach my $name (@allNodes) {	
			if (grep {$_ eq $name} @processedNodes) {				
				next;
			}
			else {	
				if ($areaOH{$name}==0) {
					$areaOH{$name} = 1;
				}
				$netGain{$name} = (($probOfFailure_COPY{$name} - $NEWPOF))/$areaOH{$name};
				$Gain{$name} = ($probOfFailure_COPY{$name} - $NEWPOF);
			}
		}			
				
		if ($areaOH{$currentNode}==0) {
			$areaOH{$currentNode} = 1;
		}
					
		printf (LOG ">POF=%0.4f, Area=%.4f, TA=%0.4f, Gain=%0.4f, Net Gain=  %0.4f, CN=$currentNode,PT=$protType{$currentGate}, OH=$areaOH{$currentNode}, GN=".($gateName.scalar @inputs-1)."\n\n", $NEWPOF*100, $circuitArea, $targetArea, (($NEWPOF-$POF)*100), (($NEWPOF-$POF)/$areaOH{$currentNode})*100);	
		printf (">POF=%0.4f, Area=%.4f, TA=%0.4f, Gain=%0.4f, Net Gain=  %0.4f, CN=$currentNode,PT=$protType{$currentGate}, OH=$areaOH{$currentNode}, GN=".($gateName.scalar @inputs-1)."\n\n", $NEWPOF*100, $circuitArea, $targetArea, (($NEWPOF-$POF)*100), (($NEWPOF-$POF)/$areaOH{$currentNode})*100);	
				
		@temp = ();
		foreach my $name (sort { $netGain{$a} <=> $netGain{$b} or $a cmp $b } keys %netGain) {
			push @temp, $name;				
		}	
		
		$currentNode = shift(@temp);						
		$POF = $NEWPOF;  
	}
	###################################################################################
	
	#------------------------------------------------------	
	#	Writing the final bench file by iterating through
	#	all the gates and based on their nType and pType
	#	variable values, apply suitable protection.
	#------------------------------------------------------	
	
	$newBenchFile = $inputFile."R_".($areaOH*100).".bench";	
	open (OUTPUT_Bench, ">$newBenchFile") or die $!;
	print OUTPUT_Bench "#Protection with Area overhead of ".($areaOH*100)."%\n";
	print OUTPUT_Bench "\n";
	print OUTPUT_Bench @IOs;
	print OUTPUT_Bench "\n";
	
	foreach $currentGate (@orderedGates) {
	
		@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.			
		$gateName = $inputs[0]; 	 
		
		if (($protType{$currentGate} == 20 )) { # or (grep {$_ eq $currentGate} @primaryOutputs)) {						
			print OUTPUT_Bench "$currentGate = D".$gateName."(";							
			for ($ii = 1; $ii < scalar @inputs; $ii++) {					
				if ($ii  == scalar @inputs - 1)	
				{	print OUTPUT_Bench "$inputs[$ii])\n";	}
				else
				{	print OUTPUT_Bench "$inputs[$ii], ";	}											
			}											
		}
		elsif (($protType{$currentGate} > 0 and $protType{$currentGate} < 9)) {
			print OUTPUT_Bench "$currentGate = $inputs[0]".(scalar @inputs -1)."$protType{$currentGate}(";								
			for ($ii = 1; $ii < scalar @inputs; $ii++) {					
				if ($ii  == scalar @inputs -1) {
					print OUTPUT_Bench "$inputs[$ii])\n";	
				}
				else {
					print OUTPUT_Bench "$inputs[$ii], ";	
				}
			}					
		}		
		elsif ($protType{$currentGate} == 0 ) { 
			print OUTPUT_Bench "$currentGate = $gateName(";							
			for ($ii = 1; $ii < scalar @inputs; $ii++) {					
				if ($ii  == scalar @inputs - 1)	
				{	print OUTPUT_Bench "$inputs[$ii])\n";	}
				else
				{	print OUTPUT_Bench "$inputs[$ii], ";	}											
			}											
		}		
		else {
			print OUTPUT_Bench $_;	
		}	
		
		if (grep $_ eq $currentGate, @primaryOutputs) {
		print OUTPUT_Bench "\n";
		}
	}
	
	print OUTPUT_Bench "END\n";
	close(OUTPUT_Bench);	
	#-------------------------------------------------------------

	my $run_time = Time::HiRes::tv_interval($start_time);
	print "\tTime taken to create Bench File = $run_time sec.\n";	
	print LOG "\n\tTime taken to create Bench File = $run_time sec.\n";	
	
	close(LOG);
}
#######################################################

sub selectionAlgorithmWithPOFSUpdate_ONLY {
	
	my $thValue = $_[0];
			
	my @orderedGates = ();
	my @sensitiveNodes = ();
	my @processedNodes = ();
	my @IOs = ();
	my %outBenchFile = ();
	my %probOfFailure = ();
	my %probOfFailure_COPY = ();
	my %detectionProb = ();
	my %strikeProb = ();
	my %protType = ();	
	my %gateConts_0 = ();
	my %gateConts_1 = ();
	my %currentCircuitGateAreas = ();	
	my %nodeAreas = ();
	my $currentArea = 0;
	my $currentNT = 0;
	my $targetArea = 0;
	
	my $verbosity = 0;
		
	%ipp = %{retrieve($inputFile.'.ipp')};
	%tech = %{retrieve('130nm.pf')};
	# print Dumper \%ipp;
	
	my @ths = qw ($thValue);
	
	my $start_time = [Time::HiRes::gettimeofday()];	
	
	$nmosDrainArea = 0.26;
	$pmosDrainArea = 0.52;
	
	################################################
	# Get Area of current Circuit
	###############################################
	system ("perl bench_to_spice_130nm.pl $inputFile 1"); 
	open(IN,"area.sp") || die " Cannot open input file area.sp \n";
	$circuitArea=0;	# area of circuit
	while(<IN>){
		$circuitArea = $_;
	}
	close(IN);
	system ("del area.sp");
	system ("del $inputFile.sp");
		
	#############################################################
	#	Read the Propagation Stats file of current circuit.		#
	#############################################################
	my %currentCircuitPropFailureProbs = ();
	$propFile = $inputFile.".prop";
	
	open (PROP_IN, $propFile) or die $!;
	while(<PROP_IN>) {
		chomp;
		@row = split('=>', $_);
		$currentCircuitPropFailureProbs{$row[0]} = $row[1];		
	}
	close(PROP_IN);	
	#############################################################
	
	#---------------------------------------------------#
	#	Save each gate in the circuit along with 		#
	#   the prob. of failure of each transistor			# 
	#	in HASH structure. 								#
	#---------------------------------------------------#
	open (INPUT_FILE, $benchFile) or die $!;	
	while (<INPUT_FILE>) {	
		if (/=/) {				
			my @gateList = split(" = ", $_);
			$gateList[1] = "= ".$gateList[1];			
						
			$currentGate = $gateList[0];				
			$outBenchFile{$currentGate} = $gateList[1];		
			push @orderedGates, $currentGate;
			
			$protType{$currentGate} = 0; #Initialize the protection type of each senstive gate to 0			
			
			#-----------------------------------------------------------#
			#	Compute Probability of failure of each transistor of	#
			#	the current selected gate.								#
			#-----------------------------------------------------------#
			
			#-------------------------------------------------
			#Generate the remaining parts of final bench file
			#-------------------------------------------------			
			@gateList = ($_ =~ m/(\w+)/g);				
			$gateName = $gateList[1];			
			@gateList = ($gateList[0], @gateList[2..$#gateList]);		

			$currentGate = $gateList[0];	
			@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.	
			
			$i1 = scalar @inputs - 1;
			if ($i1 > 4) {
				push @moreThan4Inputs, $currentGate;
			}
			
			$currentCircuitGateAreas{$currentGate} = $gateArea_130nm{$gateName.(scalar @inputs-1)};
			
			my $errorType = -1;
			my $gateType = ();
						
			$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate}/$numberOfTestVectors);
			$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate}/$numberOfTestVectors);			
								
			# process the Gates			
			my $nType = 0;
			my $pType = 0;
			my $nmos = 0;
			my $pmos = 0;			
				
			#iterate through all the N-type and P-Type transistors.
			for ($ii = 1; $ii < scalar @inputs; $ii++) {
				$nmos = "N".$ii;
				$pmos = "P".$ii;					
				
				#Compute gate controllability from the .ipp file, only once for each gate
				if ($ii==1) {
				
					#FOR NMOS
					# Read the generic failed vectors for N1
					@failedVectors = ();
					$nmos1 = $gateName.(scalar @inputs - 1)."-N$ii";						
					
					for $vector ( keys %{ $tech{$nmos1} } ) {
						push @failedVectors, $vector;						
					}										
				
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$currentGate} } ) {
						push @currentFailedVectors, $vector;						
					}
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
					
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 							
					}
					$gateConts_1{$currentGate} = $freq;
						
					#FOR PMOS
					# Read the generic failed vectors for P-Type
					@failedVectors = ();	
					$pmos1 = $gateName.(scalar @inputs - 1)."-P$ii";	
										
					for $vector ( keys %{ $tech{$pmos1} } ) {
						push @failedVectors, $vector;						
					}					
					
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$currentGate} } ) {
						push @currentFailedVectors, $vector;						
					}				
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
				
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 
					}
					$gateConts_0{$currentGate} = $freq;
					
					if ($gateConts_1{$currentGate}==0) {	$gateConts_1{$currentGate} = 1;	}
					if ($gateConts_0{$currentGate}==0) {	$gateConts_0{$currentGate} = 1;	}					
				}				
								
				$currentNode_N = $currentGate."-$nmos";
				$currentNode_P = $currentGate."-$pmos";
				
				if ($currentCircuitPropFailureProbs{$currentNode_N}*$sa0 > 0) {
					$detectionProb{$currentNode_N}	=	$currentCircuitPropFailureProbs{$currentNode_N}*$sa0/$gateConts_1{$currentGate};
					$strikeProb{$currentNode_N} 	=	$nmosDrainArea/$circuitArea;
					$nodeAreas{$currentNode_N} = $nmosDrainArea;
					$probOfFailure{$currentNode_N}	= 	$detectionProb{$currentNode_N}*$strikeProb{$currentNode_N};					
				}
				else {
					$detectionProb{$currentNode_N}	= 0;					
					$probOfFailure{$currentNode_N} = 0;						
					$nodeAreas{$currentNode_N} = $nmosDrainArea;
				}
								
				if ($currentCircuitPropFailureProbs{$currentNode_P}*$sa1 > 0) {
					$detectionProb{$currentNode_P}	=	$currentCircuitPropFailureProbs{$currentNode_P}*$sa1/$gateConts_0{$currentGate};
					$strikeProb{$currentNode_P} 	=	$pmosDrainArea/$circuitArea;
					$nodeAreas{$currentNode_P} = $pmosDrainArea;
					$probOfFailure{$currentNode_P}	= 	$detectionProb{$currentNode_P}*$strikeProb{$currentNode_P};					
				}
				else {
					$detectionProb{$currentNode_P}	= 0;
					$probOfFailure{$currentNode_P}  = 0;
					$nodeAreas{$currentNode_P} = $pmosDrainArea;
				}								
				# if ($currentGate eq "IMP8") {
					# print "Current Gate = $currentGate, inputs = @inputs, $nmos1 Area = $nmosDrainArea, $pmos1 Area = $pmosDrainArea, Total Area = $circuitArea\n";
					# print "Node = $currentNode_N, Prob SA0 = $sa0, PC1 = $gateConts_1{$currentGate}, IPP = $currentCircuitPropFailureProbs{$currentNode_N}\n";
					# print "$currentNode_N: DET = $detectionProb{$currentNode_N}, Strike = $strikeProb{$currentNode_N},  POF $nmos = $probOfFailure{$currentNode_N}\n\n";					
					# print "Node = $currentNode_P, Prob SA1 = $sa1, PC0 = $gateConts_0{$currentGate}, IPP = $currentCircuitPropFailureProbs{$currentNode_P}\n";
					# print "$currentNode_P: DET = $detectionProb{$currentNode_P}, Strike = $strikeProb{$currentNode_P},  POF $pmos = $probOfFailure{$currentNode_P}\n\n";			
				# }	

				$gatePOF{$currentGate} += $probOfFailure{$currentNode_N};
				$gatePOF{$currentGate} += $probOfFailure{$currentNode_P};				
			}					
		}		
		elsif ($_ =~ /INPUT|OUTPUT/) {
			push @IOs, $_;
		}
	} #End of Main while loop
	close(INPUT_FILE);
	#############################################################
		
	
	
	#Sort the gates according to their prob. of failure
	@sensitiveNodes = ();
	$POF = 0;
	@outputsOnly = ();
	foreach my $name (sort { $probOfFailure{$b} <=> $probOfFailure{$a} or $a cmp $b } keys %probOfFailure) {							
		 push @sensitiveNodes, $name;	
		$POF += $probOfFailure{$name};	

		$gg = (split ("-", $name))[0];
		if ( (grep {$_ eq $gg} @primaryOutputs) or ($gg =~ m/_3$/) ) {		
			push @outputsOnly, $name;
		}
		# print "N = $name, POF = $probOfFailure{$name}\n";
	}	
	$totalNodes = scalar @sensitiveNodes;
	$circuitArea = sprintf("%0.3f", $circuitArea);		
	
	# print Dumper \%gatePOF;
	
	open (POF, ">>pof.sp") or die $!;
	print POF "Circ: $inputFile, POF: $POF\n";
	close (POF);
	# printf "==>Initial POF = %0.4f, Area = $circuitArea, TH = %0.4f, Total Nodes = $totalNodes\n", $POF*100, $thValue*100;		
	printf "==>Initial POF = %0.4f, Area = $circuitArea, Total Nodes = $totalNodes\n", $POF*100;			
	%POF_ORIGINAL =  %{ dclone(\%probOfFailure) }; 	
	#############################################################
   

	#-------------------------------------------------------------#				
	open (LOG, ">$inputFile.$thValue.log") or die $!;
	print (LOG "************************************\n");  
	print (LOG "PROCESSING $inputFile ...\n\n");  
	printf (LOG "==>POF = %0.4f, Area = %0.4f, Total Nodes = %d, TH = %0.4f\n",$POF*100, $circuitArea, scalar @sensitiveNodes, $thValue*100);
	#************************************************************************
	#	Protection Code Starts from here
	#************************************************************************
	@allNodes = @{ dclone(\@sensitiveNodes) }; 
	%areaOH = ();
		
	$crg = "g212-P1";		
	
	$currentNode = shift(@outputsOnly); 
	$currentNode = shift(@sensitiveNodes); #Comment this if required to protect DMR voter only.
	
	$flag = 0;	
	$currentNodePOF = 0;		
	@sensitiveNodes = ();
	
	
	# while ($probOfFailure{$currentNode} >= $thValue) {											
	while ($POF >= $thValue and defined($currentNode)) {											
		
		if (!(grep {$_ eq $currentNode} @sensitiveNodes)) {
			push @sensitiveNodes, $currentNode;
		}
					
		@row = split("-", $currentNode);				
		$currentGate = $row[0];
		$currentType = $row[1]; # i.e. nmos or pmos		
		@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.										
		$gateName = $inputs[0]; 			
		
		my @pNodes = getProcessedNodes($currentNode, $gateName,  scalar @inputs - 1);
		foreach $ll (@pNodes) {
			if (!(grep {$_ eq $ll} @processedNodes)) {
				push @processedNodes, $ll;	
			}
		}
		
		# print "CN = $currentNode\n"; $cin=getc(STDIN);exit;
					
		if ($gateName eq "NAND") {
			$protectionType = getProtectionTypeNAND_NORMAL($protType{$currentGate}, $currentType, scalar @inputs - 1);						
		}
		elsif ($gateName eq "NOR") {
			$protectionType = getProtectionTypeNOR_NORMAL($protType{$currentGate}, $currentType, scalar @inputs - 1);		
		}		
		elsif ($gateName eq "NOT") {
			$protectionType = getProtectionTypeNOT($protType{$currentGate}, $currentType, scalar @inputs - 1);									
		}		
		
		# protecting the type e.g., NAND21, NAND32, NAND43 etc.
		$redundancyModel	=	$gateName.(scalar @inputs - 1).$protectionType;		 

		#Update Circuit Area
		$newArea = sprintf("%0.3f", $gateArea_130nm{$redundancyModel});
		$oldArea = sprintf("%0.3f", $currentCircuitGateAreas{$currentGate});
		$overHead = sprintf("%0.3f", $newArea - $oldArea);				
		$circuitArea += sprintf("%0.3f", $overHead);
		$protType{$currentGate} = $protectionType;			
		$currentCircuitGateAreas{$currentGate} +=  $overHead;
		$areaOH{$currentNode} = $overHead;
		$currentNodePOF = $probOfFailure{$currentNode};
		
		# if ($flag==1) {
			# print "CN: $currentNode, Gate Area = $currentCircuitGateAreas{$currentGate}, New AREA = $gateArea_130nm{$redundancyModel}, OH = $overHead, OA = $oldArea\n";
		# }
			
		@nodesToUpdate = ();
		if ($inputs[0] eq "NAND" or $inputs[0] eq "NOR") {
			
			for $kk (1..scalar @inputs -1) {
				push @nodesToUpdate, $currentGate."-N$kk";					
			}			
			for $kk (1..scalar @inputs -1) {
				push @nodesToUpdate, $currentGate."-P$kk";					
			}			
		}			
		elsif ($inputs[0] eq "NOT") {				
			push @nodesToUpdate, $currentGate."-N1";
			push @nodesToUpdate, $currentGate."-P1";						
		}
		
		# if ($currentNode eq "g212-P1") {
			# print "\n*******************************************************************************\n";
			# print "Protection Algorithm starting to protect $currentNode\n";
			# print "*******************************************************************************\n";
			# print "====>Current Node = $currentNode, POF = ".($probOfFailure{$currentNode}*100).", Area = $circuitArea, AREA OH = $areaOH{$currentNode}, Prev Area = ",($circuitArea-$overHead),", Prot Type = $protType{$currentGate}\n\n";		
		# } 
		
		# Iterate through the transistors list to update their POFs	
		foreach my $node (@allNodes) {

			@failedVectors = ();	

			@row = split("-", $node);				
			$CG = $row[0];
			$cType = $row[1]; # i.e. nmos or pmos	
									
			if (grep {$_ eq $node} @nodesToUpdate) {
				if ($protectionType == 20) { # FULLY PROTECTED CASE, make POFs of transistors of $currentGate to zero
					$probOfFailure{$node}	= 	0;	
					$detectionProb{$node} = 	0;
					$nodeAreas{$node} = $transArea_130nm{$redundancyModel."-$cType"};
				}
				else {
					$trans = $redundancyModel."-$cType";					
					
					for $vector ( keys %{ $tech{$trans} } ) {
						push @failedVectors, $vector;						
					}					
			
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$CG} } ) {
						push @currentFailedVectors, $vector;						
					}
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
													
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 
					}
					
					$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate}/$numberOfTestVectors);
					$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate}/$numberOfTestVectors);									
						
					$drainArea = $transArea_130nm{$trans};	
					$nodeAreas{$node} = $drainArea;
									
					$gateContProb = 0;
					$stuckAtProb = 0;
					
					if ($cType =~ m/N/i) {
						$gateContProb = $gateConts_1{$CG};
						$stuckAtProb = $sa0;
					}
					else {
						$gateContProb = $gateConts_0{$CG};
						$stuckAtProb = $sa1;
					}
					
					$detectionProb{$node}	=	($freq*$stuckAtProb)/$gateContProb;
					$strikeProb{$node} 	=	$drainArea/$circuitArea;
					$probOfFailure{$node}	= 	$detectionProb{$node}*$strikeProb{$node};					
				}
				# if (($currentNode eq "g212-P1" and $flag==1) or $verbosity ==1) {
					# print "Node = $node, protType = $protectionType,  CG = $currentGate, $trans Area = $drainArea, Total Area = $circuitArea\n";
					# print "Prob SA0 = $sa0, SA1 = $sa1, PC0 = $gateConts_0{$currentGate}, PC1 = $gateConts_1{$currentGate}, IPP = $currentCircuitPropFailureProbs{$node}\n";		
					# print "Failed Vecs. = @failedVectors\n";
					# print "Current IPP = @currentFailedVectors\nCommon = @isect\n";						
					# print "Node = $node: FREQ=$freq, DET = ",$detectionProb{$node}," HIT = ",$strikeProb{$node}," Trans-Area = $drainArea, POF $node = ",$probOfFailure{$node}*100,"\n\n";
				# }		
			}
			else {
				$drainArea = $nodeAreas{$node};				
				$strikeProb{$node} 	=	$drainArea/$circuitArea;					
				$probOfFailure{$node}	= 	$detectionProb{$node}*$strikeProb{$node};					
				
				# if ($currentNode eq "v" or $verbosity ==1) {
					# print "::Node = $node: DET = $detectionProb{$node}, HIT = $strikeProb{$node}, Trans-Area = $drainArea, POF $node = $probOfFailure{$node}\n";	
				# }
			}			
		}								
		###############################################################################
	
		$NEWPOF = 0;
		foreach my $name (@allNodes) {				
			$NEWPOF += $probOfFailure{$name};										
		}	 	
		
		# printf (LOG "POF = %0.6f\n", $NEWPOF*100);			
		
		printf (LOG ">CIRC POF= %0.4f, Area= %.4f, CN= $currentNode, Orig. POF= %0.6f, POF= %0.6f, Gain= %0.6f, Net Gain= %0.6f, PT= $protType{$currentGate}, OH= $areaOH{$currentNode}, GN=".($gateName.scalar @inputs-1)."\n", $NEWPOF*100, $circuitArea, ($POF_ORIGINAL{$currentNode}*100), ($currentNodePOF*100), ($NEWPOF-$POF)*100, ($NEWPOF-$POF)/$areaOH{$currentNode}*100 );
		
		printf (">CIRC POF=%0.4f, Area=%.4f, CN=$currentNode, Orig. POF=%0.6f, POF= %0.6f, PT=$protType{$currentGate}, OH=$areaOH{$currentNode}, GN=".($gateName.scalar @inputs-1)."\n", $NEWPOF*100, $circuitArea, ($POF_ORIGINAL{$currentNode}*100), ($currentNodePOF*100) );			
				
		@temp = ();
		foreach my $name (sort { $probOfFailure{$b} <=> $probOfFailure{$a} or $a cmp $b } keys %probOfFailure) {
			if ($probOfFailure{$name} > 0 and !(grep {$_ eq $name} @sensitiveNodes)) {
				
				#Uncomment following 4 lines if required to protect DMR voter only.
				# $gg = (split ("-", $name))[0];				
				# if ( (grep {$_ eq $gg} @primaryOutputs) or ($gg =~ m/_3$/) ) {
					# push @temp, $name;	
				# }
				
				#Uncomment the following line if required to apply STR to the whole circuit.
				push @temp, $name; 	
			}
			# print "Node = $name, POF = $probOfFailure{$name}\n";
		}		
		
		$currentNode = shift(@temp);	
		$POF = $NEWPOF;		
		
		# print "==>Next Node = $currentNode, POF = $probOfFailure{$currentNode}\n";
		
		
		###################################################################################
			
		$currentTh = $thValue;
		# if ( $probOfFailure{$currentNode} < $thValue ) { 
		if ( $POF < $thValue or !defined($currentNode)) { 
			
			#------------------------------------------------------	
			#	Writing the final bench file by iterating through
			#	all the gates and based on their nType and pType
			#	variable values, apply suitable protection.
			#------------------------------------------------------	
			
			$newBenchFile = $inputFile."R_".$currentTh.".bench";	
			open (OUTPUT_Bench, ">$newBenchFile") or die $!;
			print OUTPUT_Bench "#Protection with Threshold of  ".((1-$currentTh)*100)."%\n";
			print OUTPUT_Bench "\n";
			print OUTPUT_Bench @IOs;
			print OUTPUT_Bench "\n";
			
			foreach $currentGate (@orderedGates) {
			
				@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.			
				$gateName = $inputs[0]; 	 
				
				if (($protType{$currentGate} == 20 )) { # or (grep {$_ eq $currentGate} @primaryOutputs)) {						
					print OUTPUT_Bench "$currentGate = D".$gateName."(";							
					for ($ii = 1; $ii < scalar @inputs; $ii++) {					
						if ($ii  == scalar @inputs - 1)	
						{	print OUTPUT_Bench "$inputs[$ii])\n";	}
						else
						{	print OUTPUT_Bench "$inputs[$ii], ";	}											
					}											
				}
				elsif (($protType{$currentGate} > 0 and $protType{$currentGate} < 9)) {
					print OUTPUT_Bench "$currentGate = $inputs[0]".(scalar @inputs -1)."$protType{$currentGate}(";								
					for ($ii = 1; $ii < scalar @inputs; $ii++) {					
						if ($ii  == scalar @inputs -1) {
							print OUTPUT_Bench "$inputs[$ii])\n";	
						}
						else {
							print OUTPUT_Bench "$inputs[$ii], ";	
						}
					}					
				}		
				elsif ($protType{$currentGate} == 0 ) { 
					print OUTPUT_Bench "$currentGate = $gateName(";							
					for ($ii = 1; $ii < scalar @inputs; $ii++) {					
						if ($ii  == scalar @inputs - 1)	
						{	print OUTPUT_Bench "$inputs[$ii])\n";	}
						else
						{	print OUTPUT_Bench "$inputs[$ii], ";	}											
					}											
				}		
				else {
					print OUTPUT_Bench $_;	
				}	
				
				if (grep $_ eq $currentGate, @primaryOutputs) {
				print OUTPUT_Bench "\n";
				}
			}
			
			print OUTPUT_Bench "END\n";
			close(OUTPUT_Bench);	
			#-------------------------------------------------------------
			
			$currentTh = shift(@ths);
		}
	}
	
	my $run_time = Time::HiRes::tv_interval($start_time);
	print "\tTime taken to create Bench File = $run_time sec.\n";	
	print LOG "\n\tTime taken = $run_time sec.\n";	
	
	open (OUT, ">>area.txt") or die $!;	
	print OUT "$circuitArea \n"; close(OUT);	
	close(LOG); 
	
	# $POF = 0;
	# foreach my $name (@allNodes) {				
		# printf(LOG "> CN = $name, POF = $probOfFailure{$name}\n");										
		# print "$name: $probOfFailure{$name}\n";
	# }
	# printf(LOG "\n\nFINAL POF = $POF\n");
	
}
#######################################################

sub selectionAlgorithmWithPOFSUpdate_AREACONSTRAINT {
	
	my $areaOH = $_[0];
			
	my @orderedGates = ();
	my @sensitiveNodes = ();
	my @processedNodes = ();
	my @IOs = ();
	my %outBenchFile = ();
	my %probOfFailure = ();
	my %probOfFailure_COPY = ();
	my %detectionProb = ();
	my %strikeProb = ();
	my %protType = ();	
	my %gateConts_0 = ();
	my %gateConts_1 = ();
	my %currentCircuitGateAreas = ();	
	my %nodeAreas = ();
	my $currentArea = 0;
	my $currentNT = 0;
	my $targetArea = 0;
	
	my $verbosity = 0;
		
	%ipp = %{retrieve($inputFile.'.ipp')};
	%tech = %{retrieve('130nm.pf')};
	# print Dumper \%ipp;		
	
	my $start_time = [Time::HiRes::gettimeofday()];	
	
	$nmosDrainArea = 0.26;
	$pmosDrainArea = 0.52;
	
	################################################
	# Get Area of current Circuit
	################################################
	system ("perl bench_to_spice_130nm.pl $inputFile 1");
	open(IN,"area.sp") || die " Cannot open input file area.sp \n";
	$circuitArea=0;	# area of circuit
	while(<IN>){
		$circuitArea = $_;
	}
	close(IN);
	system ("del area.sp");
	system ("del $inputFile.sp");
	
	# $circuitArea = 42.12;
	# $circuitArea = 338.31;
	# $circuitArea = 1047.33;
	
	# $circuitArea = 1.08;
	# $circuitArea = 3.150;
	
	#############################################################
	#	Read the Propagation Stats file of current circuit.		#
	#############################################################
	my %currentCircuitPropFailureProbs = ();
	$propFile = $inputFile.".prop";
	
	open (PROP_IN, $propFile) or die $!;
	while(<PROP_IN>) {
		chomp;
		@row = split('=>', $_);
		$currentCircuitPropFailureProbs{$row[0]} = $row[1];		
	}
	close(PROP_IN);	
	#############################################################
	
	#---------------------------------------------------#
	#	Save each gate in the circuit along with 		#
	#   the prob. of failure of each transistor			# 
	#	in HASH structure. 								#
	#---------------------------------------------------#
	open (INPUT_FILE, $benchFile) or die $!;	
	while (<INPUT_FILE>) {	
		if (/=/) {				
			my @gateList = split(" = ", $_);
			$gateList[1] = "= ".$gateList[1];			
						
			$currentGate = $gateList[0];				
			$outBenchFile{$currentGate} = $gateList[1];		
			push @orderedGates, $currentGate;
			
			$protType{$currentGate} = 0; #Initialize the protection type of each senstive gate to 0			
			
			#-----------------------------------------------------------#
			#	Compute Probability of failure of each transistor of	#
			#	the current selected gate.								#
			#-----------------------------------------------------------#
			
			#-------------------------------------------------
			#Generate the remaining parts of final bench file
			#-------------------------------------------------			
			@gateList = ($_ =~ m/(\w+)/g);				
			$gateName[0] = $gateList[1];			
			@gateList = ($gateList[0], @gateList[2..$#gateList]);		

			$currentGate = $gateList[0];	
			@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.	
			$gateName = $inputs[0]; 	
			
			$currentCircuitGateAreas{$currentGate} = $gateArea_130nm{$gateName.(scalar @inputs-1)};
			
			my $errorType = -1;
			my $gateType = ();
						
			$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate}/$numberOfTestVectors);
			$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate}/$numberOfTestVectors);			
								
			# process the Gates			
			my $nType = 0;
			my $pType = 0;
			my $nmos = 0;
			my $pmos = 0;			
				
			#iterate through all the N-type and P-Type transistors.
			for ($ii = 1; $ii < scalar @inputs; $ii++) {
				$nmos = "N".$ii;
				$pmos = "P".$ii;					
				
				#Compute gate controllability from the .ipp file, only once for each gate
				if ($ii==1) {
				
					#FOR NMOS
					# Read the generic failed vectors for N1
					@failedVectors = ();
					$nmos1 = $gateName.(scalar @inputs - 1)."-N$ii";						
					
					for $vector ( keys %{ $tech{$nmos1} } ) {
						push @failedVectors, $vector;						
					}										
				
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$currentGate} } ) {
						push @currentFailedVectors, $vector;						
					}
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
					
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 							
					}
					$gateConts_1{$currentGate} = $freq;
						
					#FOR PMOS
					# Read the generic failed vectors for P-Type
					@failedVectors = ();	
					$pmos1 = $gateName.(scalar @inputs - 1)."-P$ii";	
										
					for $vector ( keys %{ $tech{$pmos1} } ) {
						push @failedVectors, $vector;						
					}					
					
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$currentGate} } ) {
						push @currentFailedVectors, $vector;						
					}				
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
				
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 
					}
					$gateConts_0{$currentGate} = $freq;
					
					if ($gateConts_1{$currentGate}==0) {	$gateConts_1{$currentGate} = 1;	}
					if ($gateConts_0{$currentGate}==0) {	$gateConts_0{$currentGate} = 1;	}					
				}				
								
				$currentNode_N = $currentGate."-$nmos";
				$currentNode_P = $currentGate."-$pmos";
				
				if ($currentCircuitPropFailureProbs{$currentNode_N}*$sa0 > 0) {
					$detectionProb{$currentNode_N}	=	$currentCircuitPropFailureProbs{$currentNode_N}*$sa0/$gateConts_1{$currentGate};
					$strikeProb{$currentNode_N} 	=	$nmosDrainArea/$circuitArea;
					$nodeAreas{$currentNode_N} = $nmosDrainArea;
					$probOfFailure{$currentNode_N}	= 	$detectionProb{$currentNode_N}*$strikeProb{$currentNode_N};					
				}
				else {
					$detectionProb{$currentNode_N}	= 0;					
					$probOfFailure{$currentNode_N} = 0;						
					$nodeAreas{$currentNode_N} = $nmosDrainArea;
				}
								
				if ($currentCircuitPropFailureProbs{$currentNode_P}*$sa1 > 0) {
					$detectionProb{$currentNode_P}	=	$currentCircuitPropFailureProbs{$currentNode_P}*$sa1/$gateConts_0{$currentGate};
					$strikeProb{$currentNode_P} 	=	$pmosDrainArea/$circuitArea;
					$nodeAreas{$currentNode_P} = $pmosDrainArea;
					$probOfFailure{$currentNode_P}	= 	$detectionProb{$currentNode_P}*$strikeProb{$currentNode_P};					
				}
				else {
					$detectionProb{$currentNode_P}	= 0;
					$probOfFailure{$currentNode_P}  = 0;
					$nodeAreas{$currentNode_P} = $pmosDrainArea;
				}								
				# if ($currentGate eq "g" or $verbosity == 1) {
					# print "Current Gate = $currentGate, inputs = @inputs, $nmos1 Area = $nmosDrainArea, $pmos1 Area = $pmosDrainArea, Total Area = $circuitArea\n";
					# print "Node = $currentNode_N, Prob SA0 = $sa0, PC1 = $gateConts_1{$currentGate}, IPP = $currentCircuitPropFailureProbs{$currentNode_N}\n";
					# print "$currentNode_N: DET = $detectionProb{$currentNode_N}, Strike = $strikeProb{$currentNode_N},  POF $nmos = $probOfFailure{$currentNode_N}\n\n";					
					# print "Node = $currentNode_P, Prob SA1 = $sa1, PC0 = $gateConts_0{$currentGate}, IPP = $currentCircuitPropFailureProbs{$currentNode_P}\n";
					# print "$currentNode_P: DET = $detectionProb{$currentNode_P}, Strike = $strikeProb{$currentNode_P},  POF $pmos = $probOfFailure{$currentNode_P}\n\n";			
				# }				
			}					
		}		
		elsif ($_ =~ /INPUT|OUTPUT/) {
			push @IOs, $_;
		}
	} #End of Main while loop
	close(INPUT_FILE);
	#############################################################
		
	open (LOG, ">$inputFile.$areaOH.log") or die $!;
	
	#Sort the gates according to their prob. of failure
	@sensitiveNodes = ();
	$POF = 0;		 
	foreach my $name (sort { $probOfFailure{$b} <=> $probOfFailure{$a} or $a cmp $b } keys %probOfFailure) {					
		push @sensitiveNodes, $name;	
		$POF += $probOfFailure{$name};		
		# print "N = $name, POF = $probOfFailure{$name}\n";
	}	
	$totalNodes = scalar @sensitiveNodes;
	
	$circuitArea = sprintf("%0.3f", $circuitArea);
	$targetArea = $circuitArea + ($circuitArea*$areaOH);
	
	printf "==>Initial POF = %0.4f, Area = $circuitArea, TH = %0.4f, Total Nodes = $totalNodes\n", $POF*100, $areaOH*100;		
	%POF_ORIGINAL =  %{ dclone(\%probOfFailure) };			
	
	#############################################################
   

	#-------------------------------------------------------------#				
	
	print (LOG "************************************\n");  
	print (LOG "PROCESSING $inputFile ...\n\n");  
	printf (LOG "==>POF = %0.4f, Area = %0.4f, Total Nodes = %d, TH = %0.4f\n",$POF*100, $circuitArea, scalar @sensitiveNodes, $areaOH*100);
	
	#************************************************************************
	#	Protection Code Starts from here
	#************************************************************************
	@allNodes = @{ dclone(\@sensitiveNodes) }; 
	%areaOH = ();
		
	$crg = "g212-P1";	
	$currentNode = shift(@sensitiveNodes);
	
	$flag = 0;	
	$currentNodePOF = 0;		
	@sensitiveNodes = ();
											
	while ($circuitArea < $targetArea and $POF > 0) {											
		
		if (!(grep {$_ eq $currentNode} @sensitiveNodes)) {
			push @sensitiveNodes, $currentNode;
		}
					
		@row = split("-", $currentNode);				
		$currentGate = $row[0];
		$currentType = $row[1]; # i.e. nmos or pmos		
		@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.										
		$gateName = $inputs[0]; 			
		
		my @pNodes = getProcessedNodes($currentNode, $gateName,  scalar @inputs - 1);
		foreach $ll (@pNodes) {
			if (!(grep {$_ eq $ll} @processedNodes)) {
				push @processedNodes, $ll;	
			}
		}
		
		# print "processed nodes = @processedNodes \n"; $cin=getc(STDIN);
					
		if ($gateName eq "NAND") {
			$protectionType = getProtectionTypeNAND_NORMAL($protType{$currentGate}, $currentType, scalar @inputs - 1);						
		}
		elsif ($gateName eq "NOR") {
			$protectionType = getProtectionTypeNOR_NORMAL($protType{$currentGate}, $currentType, scalar @inputs - 1);		
		}		
		elsif ($gateName eq "NOT") {
			$protectionType = getProtectionTypeNOT($protType{$currentGate}, $currentType, scalar @inputs - 1);									
		}		
		
		# protecting the type e.g., NAND21, NAND32, NAND43 etc.
		$redundancyModel	=	$gateName.(scalar @inputs - 1).$protectionType;		 

		#Update Circuit Area
		$newArea = sprintf("%0.3f", $gateArea_130nm{$redundancyModel});
		$oldArea = sprintf("%0.3f", $currentCircuitGateAreas{$currentGate});
		$overHead = sprintf("%0.3f", $newArea - $oldArea);				
		$circuitArea += sprintf("%0.3f", $overHead);
		$protType{$currentGate} = $protectionType;			
		$currentCircuitGateAreas{$currentGate} +=  $overHead;
		$areaOH{$currentNode} = $overHead;
		$currentNodePOF = $probOfFailure{$currentNode};
				
		# if ($flag==1) {
			# print "CN: $currentNode, Gate Area = $currentCircuitGateAreas{$currentGate}, New AREA = $gateArea_130nm{$redundancyModel}, OH = $overHead, OA = $oldArea\n";
		# }
			
		@nodesToUpdate = ();
		if ($inputs[0] eq "NAND" or $inputs[0] eq "NOR") {
			
			for $kk (1..scalar @inputs -1) {
				push @nodesToUpdate, $currentGate."-N$kk";					
			}			
			for $kk (1..scalar @inputs -1) {
				push @nodesToUpdate, $currentGate."-P$kk";					
			}			
		}			
		elsif ($inputs[0] eq "NOT") {				
			push @nodesToUpdate, $currentGate."-N1";
			push @nodesToUpdate, $currentGate."-P1";						
		}
		
		# if ($currentNode eq "g212-P1") {
			# print "\n*******************************************************************************\n";
			# print "Protection Algorithm starting to protect $currentNode\n";
			# print "*******************************************************************************\n";
			# print "====>Current Node = $currentNode, POF = ".($probOfFailure{$currentNode}*100).", Area = $circuitArea, AREA OH = $areaOH{$currentNode}, Prev Area = ",($circuitArea-$overHead),", Prot Type = $protType{$currentGate}\n\n";		
		# } 
		
		# Iterate through the transistors list to update their POFs	
		foreach my $node (@allNodes) {

			@failedVectors = ();	

			@row = split("-", $node);				
			$CG = $row[0];
			$cType = $row[1]; # i.e. nmos or pmos	
									
			if (grep {$_ eq $node} @nodesToUpdate) {
				if ($protectionType == 20) { # FULLY PROTECTED CASE, make POFs of transistors of $currentGate to zero
					$probOfFailure{$node}	= 	0;	
					$detectionProb{$node} = 	0;
					$nodeAreas{$node} = $transArea_130nm{$redundancyModel."-$cType"};
				}
				else {
					$trans = $redundancyModel."-$cType";					
					
					for $vector ( keys %{ $tech{$trans} } ) {
						push @failedVectors, $vector;						
					}					
			
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$CG} } ) {
						push @currentFailedVectors, $vector;						
					}
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
													
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 
					}
					
					$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate}/$numberOfTestVectors);
					$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate}/$numberOfTestVectors);									
						
					$drainArea = $transArea_130nm{$trans};	
					$nodeAreas{$node} = $drainArea;
									
					$gateContProb = 0;
					$stuckAtProb = 0;
					
					if ($cType =~ m/N/i) {
						$gateContProb = $gateConts_1{$CG};
						$stuckAtProb = $sa0;
					}
					else {
						$gateContProb = $gateConts_0{$CG};
						$stuckAtProb = $sa1;
					}
					
					$detectionProb{$node}	=	($freq*$stuckAtProb)/$gateContProb;
					$strikeProb{$node} 	=	$drainArea/$circuitArea;
					$probOfFailure{$node}	= 	$detectionProb{$node}*$strikeProb{$node};					
				}
				# if (($currentNode eq "g212-P1" and $flag==1) or $verbosity ==1) {
					# print "Node = $node, protType = $protectionType,  CG = $currentGate, $trans Area = $drainArea, Total Area = $circuitArea\n";
					# print "Prob SA0 = $sa0, SA1 = $sa1, PC0 = $gateConts_0{$currentGate}, PC1 = $gateConts_1{$currentGate}, IPP = $currentCircuitPropFailureProbs{$node}\n";		
					# print "Failed Vecs. = @failedVectors\n";
					# print "Current IPP = @currentFailedVectors\nCommon = @isect\n";						
					# print "Node = $node: FREQ=$freq, DET = ",$detectionProb{$node}," HIT = ",$strikeProb{$node}," Trans-Area = $drainArea, POF $node = ",$probOfFailure{$node}*100,"\n\n";
				# }		
			}
			else {
				$drainArea = $nodeAreas{$node};				
				$strikeProb{$node} 	=	$drainArea/$circuitArea;					
				$probOfFailure{$node}	= 	$detectionProb{$node}*$strikeProb{$node};					
				
				# if ($currentNode eq "v" or $verbosity ==1) {
					# print "::Node = $node: DET = $detectionProb{$node}, HIT = $strikeProb{$node}, Trans-Area = $drainArea, POF $node = $probOfFailure{$node}\n";	
				# }
			}			
		}								
		###############################################################################
	
		$NEWPOF = 0;
		foreach my $name (@allNodes) {				
			$NEWPOF += $probOfFailure{$name};										
		}	 	
		
		# printf (LOG "POF = %0.6f\n", $NEWPOF*100);			
		
		printf (LOG ">CIRC POF= %0.4f, Area= %.4f, TA=%0.4f, CN= $currentNode, Orig. POF= %0.6f, POF= %0.6f, Gain= %0.6f, Net Gain= %0.6f, PT= $protType{$currentGate}, OH= $areaOH{$currentNode}, GN=".($gateName.scalar @inputs-1)."\n", $NEWPOF*100, $circuitArea, $targetArea, ($POF_ORIGINAL{$currentNode}*100), ($currentNodePOF*100), ($NEWPOF-$POF)*100, ($NEWPOF-$POF)/$areaOH{$currentNode}*100 );
		
		printf (">CIRC POF=%0.4f, Area=%.4f, TA=%0.4f, CN=$currentNode, Orig. POF=%0.6f, POF= %0.6f, PT=$protType{$currentGate}, OH=$areaOH{$currentNode}, GN=".($gateName.scalar @inputs-1)."\n", $NEWPOF*100, $circuitArea, $targetArea, ($POF_ORIGINAL{$currentNode}*100), ($currentNodePOF*100) );			
				
		@temp = ();
		foreach my $name (sort { $probOfFailure{$b} <=> $probOfFailure{$a} or $a cmp $b } keys %probOfFailure) {
			if ($probOfFailure{$name} > 0 and !(grep {$_ eq $name} @sensitiveNodes)) {
				push @temp, $name;				
			}
			# print "Node = $name, POF = $probOfFailure{$name}\n";
		}		
		
		$currentNode = shift(@temp);	
		$POF = $NEWPOF;		
		
		# print "==>Next Node = $currentNode, POF = $probOfFailure{$currentNode}\n";
	}
		###################################################################################
			
	#------------------------------------------------------	
	#	Writing the final bench file by iterating through
	#	all the gates and based on their nType and pType
	#	variable values, apply suitable protection.
	#------------------------------------------------------	
	
	$newBenchFile = $inputFile."R_".($areaOH*100).".bench";	
	open (OUTPUT_Bench, ">$newBenchFile") or die $!;
	print OUTPUT_Bench "#Protection with Area overhead of ".($areaOH*100)."%\n";
	print OUTPUT_Bench "\n";
	print OUTPUT_Bench @IOs;
	print OUTPUT_Bench "\n";
	
	foreach $currentGate (@orderedGates) {
	
		@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.			
		$gateName = $inputs[0]; 	 
		
		if (($protType{$currentGate} == 20 )) { # or (grep {$_ eq $currentGate} @primaryOutputs)) {						
			print OUTPUT_Bench "$currentGate = D".$gateName."(";							
			for ($ii = 1; $ii < scalar @inputs; $ii++) {					
				if ($ii  == scalar @inputs - 1)	
				{	print OUTPUT_Bench "$inputs[$ii])\n";	}
				else
				{	print OUTPUT_Bench "$inputs[$ii], ";	}											
			}											
		}
		elsif (($protType{$currentGate} > 0 and $protType{$currentGate} < 9)) {
			print OUTPUT_Bench "$currentGate = $inputs[0]".(scalar @inputs -1)."$protType{$currentGate}(";								
			for ($ii = 1; $ii < scalar @inputs; $ii++) {					
				if ($ii  == scalar @inputs -1) {
					print OUTPUT_Bench "$inputs[$ii])\n";	
				}
				else {
					print OUTPUT_Bench "$inputs[$ii], ";	
				}
			}					
		}		
		elsif ($protType{$currentGate} == 0 ) { 
			print OUTPUT_Bench "$currentGate = $gateName(";							
			for ($ii = 1; $ii < scalar @inputs; $ii++) {					
				if ($ii  == scalar @inputs - 1)	
				{	print OUTPUT_Bench "$inputs[$ii])\n";	}
				else
				{	print OUTPUT_Bench "$inputs[$ii], ";	}											
			}											
		}		
		else {
			print OUTPUT_Bench $_;	
		}	
		
		if (grep $_ eq $currentGate, @primaryOutputs) {
		print OUTPUT_Bench "\n";
		}
	}
	
	print OUTPUT_Bench "END\n";
	close(OUTPUT_Bench);	
	#-------------------------------------------------------------
	
	my $run_time = Time::HiRes::tv_interval($start_time);
	print "\tTime taken to create Bench File = $run_time sec.\n";	
	print LOG "\n\tTime taken = $run_time sec.\n";	
	
	# $POF = 0;
	# foreach my $name (@allNodes) {				
		# printf(LOG "> CN = $name, POF = $probOfFailure{$name}\n");										
		# $POF += $probOfFailure{$name};
	# }
	# printf(LOG "\n\nFINAL POF = $POF\n");
	
	close(LOG);
}
#######################################################

sub selectionAlgorithm_SymmetricScaling_ZhouPaper{
	
	my $thValue = $_[0];
			
	my @orderedGates = ();
	my @sensitiveNodes = ();
	my @processedNodes = ();
	my @IOs = ();
	my %outBenchFile = ();
	my %probOfFailure = ();
	my %probOfFailure_COPY = ();
	my %detectionProb = ();
	my %strikeProb = ();
	my %protType = ();	
	my %gateConts_0 = ();
	my %gateConts_1 = ();
	my %currentCircuitGateAreas = ();	
	my %nodeAreas = ();
	my %collapsedFaultProb = ();
	my $currentArea = 0;
	my $currentNT = 0;
	my $targetArea = 0;
	
	my $verbosity = 0;
		
	%ipp = %{retrieve($inputFile.'.ipp')};
	%tech = %{retrieve('130nm.pf')};
	# print Dumper \%ipp;
	
	my @ths = qw ($thValue);
	
	my $start_time = [Time::HiRes::gettimeofday()];	
	
	$nmosDrainArea = 0.26;
	$pmosDrainArea = 0.52;
	
	################################################
	# Get Area of current Circuit
	###############################################
	system ("perl bench_to_spice_130nm.pl $inputFile 1");
	open(IN,"area.sp") || die " Cannot open input file area.sp \n";
	$circuitArea=0;	# area of circuit
	while(<IN>){
		$circuitArea = $_;
	}
	close(IN);
	system ("del area.sp");
	system ("del $inputFile.sp");
			
	#############################################################
	#	Read the Propagation Stats file of current circuit.		#
	#############################################################
	my %currentCircuitPropFailureProbs = ();
	$propFile = $inputFile.".prop";
	
	open (PROP_IN, $propFile) or die $!;
	while(<PROP_IN>) {
		chomp;
		@row = split('=>', $_);
		$currentCircuitPropFailureProbs{$row[0]} = $row[1];		
	}
	close(PROP_IN);	
	#############################################################
	
	#---------------------------------------------------#
	#	Save each gate in the circuit along with 		#
	#   the prob. of failure of each transistor			# 
	#	in HASH structure. 								#
	#---------------------------------------------------#
	open (INPUT_FILE, $benchFile) or die $!;	
	while (<INPUT_FILE>) {	
		if (/=/) {				
			my @gateList = split(" = ", $_);
			$gateList[1] = "= ".$gateList[1];			
						
			$currentGate = $gateList[0];				
			$outBenchFile{$currentGate} = $gateList[1];		
			push @orderedGates, $currentGate;
			
			$protType{$currentGate} = 0; #Initialize the protection type of each senstive gate to 0			
			
			#-----------------------------------------------------------#
			#	Compute Probability of failure of each transistor of	#
			#	the current selected gate.								#
			#-----------------------------------------------------------#
			
			#-------------------------------------------------
			#Generate the remaining parts of final bench file
			#-------------------------------------------------			
			@gateList = ($_ =~ m/(\w+)/g);				
			$gateName[0] = $gateList[1];			
			@gateList = ($gateList[0], @gateList[2..$#gateList]);		

			$currentGate = $gateList[0];	
			@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.	
			$gateName = $inputs[0]; 	
			
			$currentCircuitGateAreas{$currentGate} = $gateArea_Zhou_130nm{$gateName.(scalar @inputs-1)};
			
			my $errorType = -1;
			my $gateType = ();
						
			$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate}/$numberOfTestVectors);
			$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate}/$numberOfTestVectors);	

			$collapsedFaultProb{$currentGate} = $sa0 + $sa1;
								
			# process the Gates			
			my $nType = 0;
			my $pType = 0;
			my $nmos = 0;
			my $pmos = 0;			
				
			#iterate through all the N-type and P-Type transistors.
			for ($ii = 1; $ii < scalar @inputs; $ii++) {
				$nmos = "N".$ii;
				$pmos = "P".$ii;					
				
				#Compute gate controllability from the .ipp file, only once for each gate
				if ($ii==1) {
				
					#FOR NMOS
					# Read the generic failed vectors for N1
					@failedVectors = ();
					$nmos1 = $gateName.(scalar @inputs - 1)."-N$ii";						
					
					for $vector ( keys %{ $tech{$nmos1} } ) {
						push @failedVectors, $vector;						
					}										
				
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$currentGate} } ) {
						push @currentFailedVectors, $vector;						
					}
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
					
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 							
					}
					$gateConts_1{$currentGate} = $freq;
						
					#FOR PMOS
					# Read the generic failed vectors for P-Type
					@failedVectors = ();	
					$pmos1 = $gateName.(scalar @inputs - 1)."-P$ii";	
										
					for $vector ( keys %{ $tech{$pmos1} } ) {
						push @failedVectors, $vector;						
					}					
					
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$currentGate} } ) {
						push @currentFailedVectors, $vector;						
					}				
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
				
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 
					}
					$gateConts_0{$currentGate} = $freq;
					
					if ($gateConts_1{$currentGate}==0) {	$gateConts_1{$currentGate} = 1;	}
					if ($gateConts_0{$currentGate}==0) {	$gateConts_0{$currentGate} = 1;	}					
				}				
								
				$currentNode_N = $currentGate."-$nmos";
				$currentNode_P = $currentGate."-$pmos";
				
				if ($currentCircuitPropFailureProbs{$currentNode_N}*$sa0 > 0) {
					$detectionProb{$currentNode_N}	=	$currentCircuitPropFailureProbs{$currentNode_N}*$sa0/$gateConts_1{$currentGate};
					$strikeProb{$currentNode_N} 	=	$nmosDrainArea/$circuitArea;
					$nodeAreas{$currentNode_N} = $nmosDrainArea;
					$probOfFailure{$currentNode_N}	= 	$detectionProb{$currentNode_N}*$strikeProb{$currentNode_N};					
				}
				else {
					$detectionProb{$currentNode_N}	= 0;					
					$probOfFailure{$currentNode_N} = 0;						
					$nodeAreas{$currentNode_N} = $nmosDrainArea;
				}
								
				if ($currentCircuitPropFailureProbs{$currentNode_P}*$sa1 > 0) {
					$detectionProb{$currentNode_P}	=	$currentCircuitPropFailureProbs{$currentNode_P}*$sa1/$gateConts_0{$currentGate};
					$strikeProb{$currentNode_P} 	=	$pmosDrainArea/$circuitArea;
					$nodeAreas{$currentNode_P} = $pmosDrainArea;
					$probOfFailure{$currentNode_P}	= 	$detectionProb{$currentNode_P}*$strikeProb{$currentNode_P};					
				}
				else {
					$detectionProb{$currentNode_P}	= 0;
					$probOfFailure{$currentNode_P}  = 0;
					$nodeAreas{$currentNode_P} = $pmosDrainArea;
				}								
				# if ($currentGate eq "g" or $verbosity == 1) {
					# print "Current Gate = $currentGate, inputs = @inputs, $nmos1 Area = $nmosDrainArea, $pmos1 Area = $pmosDrainArea, Total Area = $circuitArea\n";
					# print "Node = $currentNode_N, Prob SA0 = $sa0, PC1 = $gateConts_1{$currentGate}, IPP = $currentCircuitPropFailureProbs{$currentNode_N}\n";
					# print "$currentNode_N: DET = $detectionProb{$currentNode_N}, Strike = $strikeProb{$currentNode_N},  POF $nmos = $probOfFailure{$currentNode_N}\n\n";					
					# print "Node = $currentNode_P, Prob SA1 = $sa1, PC0 = $gateConts_0{$currentGate}, IPP = $currentCircuitPropFailureProbs{$currentNode_P}\n";
					# print "$currentNode_P: DET = $detectionProb{$currentNode_P}, Strike = $strikeProb{$currentNode_P},  POF $pmos = $probOfFailure{$currentNode_P}\n\n";			
				# }				
			}					
		}		
		elsif ($_ =~ /INPUT|OUTPUT/) {
			push @IOs, $_;
		}
	} #End of Main while loop
	close(INPUT_FILE);
	#############################################################
		
	open (LOG, ">$inputFile.$thValue.log") or die $!;
	
	#Sort the gates according to their prob. of failure
	@sensitiveGates = ();
	foreach my $name (sort { $collapsedFaultProb{$b} <=> $collapsedFaultProb{$a} } keys %collapsedFaultProb) {					
		push @sensitiveGates, $name;	
		# print "N = $name, Collapsed = $collapsedFaultProb{$name}\n";
	
	}	
	
	# print Dumper \%collapsedFaultProb; 
	# print Dumper @sensitiveGates;
		
	@sensitiveNodes = ();
	$POF = 0;		 
	foreach my $name (sort { $probOfFailure{$b} <=> $probOfFailure{$a} or $a cmp $b } keys %probOfFailure) {					
		push @sensitiveNodes, $name;	
		$POF += $probOfFailure{$name};		
		# print "N = $name, POF = $collapsedFaultProb{$name}\n";
	}	
	$totalNodes = scalar @sensitiveNodes;
	$circuitArea = sprintf("%0.3f", $circuitArea);
	$targetArea = $circuitArea + ($circuitArea*$thValue);		
	
	printf "==>Initial POF = %0.4f, Area = $circuitArea, TH = %0.4f, Total Nodes = $totalNodes\n", $POF*100, $thValue*100;		
	%POF_ORIGINAL =  %{ dclone(\%probOfFailure) };		
	#############################################################
   

	#-------------------------------------------------------------#				
	
	print (LOG "************************************\n");  
	print (LOG "PROCESSING $inputFile ...\n\n");  
	printf (LOG "==>POF = %0.4f, Area = %0.4f, Total Nodes = %d, TH = %0.4f\n",$POF*100, $circuitArea, scalar @sensitiveNodes, $thValue*100);
	
	#************************************************************************
	#	Protection Code Starts from here
	#************************************************************************
	@allNodes = @{ dclone(\@sensitiveNodes) }; 	
	%areaOH = ();
		
	$crg = "g212-P1";	
	$currentGate = shift(@sensitiveGates);
	print "\nCurrent Gate = $currentGate, POF = $collapsedFaultProb{$currentGate}\n";
	
	$flag = 0;	
	$currentNodePOF = 0;			
	@sensitiveGates = ();
	
	while ($POF >= $thValue) {		
	# while ($circuitArea < $targetArea and $POF > 0) {				
		
		if (!(grep {$_ eq $currentGate} @sensitiveGates)) {
			push @sensitiveGates, $currentGate;
		}
					
		@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.										
		$gateName = $inputs[0]; 			
		
		$protectionType = 20;
		$collapsedFaultProb{$currentGate} = 0;
		
		# protecting the type e.g., NAND21, NAND32, NAND43 etc.
		$redundancyModel	=	$gateName.(scalar @inputs - 1).$protectionType;		 

		#Update Circuit Area
		$newArea = sprintf("%0.3f", $gateArea_Zhou_130nm{$redundancyModel});
		$oldArea = sprintf("%0.3f", $currentCircuitGateAreas{$currentGate});
		$overHead = sprintf("%0.3f", $newArea - $oldArea);				
		$circuitArea += sprintf("%0.3f", $overHead);
		$protType{$currentGate} = $protectionType;			
		$currentCircuitGateAreas{$currentGate} +=  $overHead;
		$areaOH{$currentGate} = $overHead;
				
		# if ($flag==1) {
			# print "CN: $currentGate, Gate Area = $currentCircuitGateAreas{$currentGate}, New AREA = $gateArea_Zhou_130nm{$redundancyModel}, OH = $overHead, OA = $oldArea\n";
		# }
			
		@nodesToUpdate = ();
		if ($inputs[0] eq "NAND" or $inputs[0] eq "NOR") {
			
			for $kk (1..scalar @inputs -1) {
				push @nodesToUpdate, $currentGate."-N$kk";					
			}			
			for $kk (1..scalar @inputs -1) {
				push @nodesToUpdate, $currentGate."-P$kk";					
			}			
		}			
		elsif ($inputs[0] eq "NOT") {				
			push @nodesToUpdate, $currentGate."-N1";
			push @nodesToUpdate, $currentGate."-P1";						
		}
		
		# if ($currentGate eq "g212-P1") {
			# print "\n*******************************************************************************\n";
			# print "Protection Algorithm starting to protect $currentGate\n";
			# print "*******************************************************************************\n";
			# print "====>Current Node = $currentGate, POF = ".($probOfFailure{$currentGate}*100).", Area = $circuitArea, AREA OH = $areaOH{$currentGate}, Prev Area = ",($circuitArea-$overHead),", Prot Type = $protType{$currentGate}\n\n";		
		# } 
				
		
		# Iterate through the transistors list to update their POFs	
		foreach my $node (@allNodes) {

			@failedVectors = ();	

			@row = split("-", $node);				
			$CG = $row[0];
			$cType = $row[1]; # i.e. nmos or pmos	
									
			if (grep {$_ eq $node} @nodesToUpdate) {
				if ($protectionType == 20) { # FULLY PROTECTED CASE, make POFs of transistors of $currentGate to zero
					$probOfFailure{$node}	= 	0;	
					$detectionProb{$node} = 	0;
					$nodeAreas{$node} = $transArea_Zhou_130nm{$redundancyModel."-$cType"}; 
				}
				else {
					$trans = $redundancyModel."-$cType";					
					
					for $vector ( keys %{ $tech{$trans} } ) {
						push @failedVectors, $vector;						
					}					
			
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$CG} } ) {
						push @currentFailedVectors, $vector;						
					}
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
													
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 
					}
					
					$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate}/$numberOfTestVectors);
					$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate}/$numberOfTestVectors);									
						
					$drainArea = $transArea_Zhou_130nm{$trans};	
					$nodeAreas{$node} = $drainArea;
									
					$gateContProb = 0;
					$stuckAtProb = 0;
					
					if ($cType =~ m/N/i) {
						$gateContProb = $gateConts_1{$CG};
						$stuckAtProb = $sa0;
					}
					else {
						$gateContProb = $gateConts_0{$CG};
						$stuckAtProb = $sa1;
					}
					
					$detectionProb{$node}	=	($freq*$stuckAtProb)/$gateContProb;
					$strikeProb{$node} 	=	$drainArea/$circuitArea;
					$probOfFailure{$node}	= 	$detectionProb{$node}*$strikeProb{$node};					
				}
				# if (($currentGate eq "g212-P1" and $flag==1) or $verbosity ==1) {
					# print "Node = $node, protType = $protectionType,  CG = $currentGate, $trans Area = $drainArea, Total Area = $circuitArea\n";
					# print "Prob SA0 = $sa0, SA1 = $sa1, PC0 = $gateConts_0{$currentGate}, PC1 = $gateConts_1{$currentGate}, IPP = $currentCircuitPropFailureProbs{$node}\n";		
					# print "Failed Vecs. = @failedVectors\n";
					# print "Current IPP = @currentFailedVectors\nCommon = @isect\n";						
					# print "Node = $node: FREQ=$freq, DET = ",$detectionProb{$node}," HIT = ",$strikeProb{$node}," Trans-Area = $drainArea, POF $node = ",$probOfFailure{$node}*100,"\n\n";
				# }		
			}
			else {
				$drainArea = $nodeAreas{$node};				
				$strikeProb{$node} 	=	$drainArea/$circuitArea;					
				$probOfFailure{$node}	= 	$detectionProb{$node}*$strikeProb{$node};					
				
				# if ($currentGate eq "v" or $verbosity ==1) {
					# print "::Node = $node: DET = $detectionProb{$node}, HIT = $strikeProb{$node}, Trans-Area = $drainArea, POF $node = $probOfFailure{$node}\n";	
				# }
			}			
		}								
		###############################################################################
	
		$NEWPOF = 0;
		foreach my $name (@allNodes) {				
			$NEWPOF += $probOfFailure{$name};										
		}	 	
		$NEWPOF += 0.0045;
		# printf (LOG "POF = %0.6f\n", $NEWPOF*100);					
		printf (LOG ">CIRC POF= %0.4f, Area= %.4f, CG= $currentGate\n", $NEWPOF*100, $circuitArea);		
		printf (">CIRC POF= %0.4f, Area= %.4f, CG= $currentGate\n", $NEWPOF*100, $circuitArea);				
		@temp = ();
		foreach my $name (sort { $collapsedFaultProb{$b} <=> $collapsedFaultProb{$a} } keys %collapsedFaultProb) {
			if ($collapsedFaultProb{$name} > 0 and !(grep {$_ eq $name} @sensitiveGates)) {
				push @temp, $name;				
			}
			# print "Node = $name, POF = $collapsedFaultProb{$currentGate}\n";
		}		
		
		$currentGate = shift(@temp);	
		$POF = $NEWPOF;		
		
		# print "\n==>Next Gate = $currentGate, POF = $collapsedFaultProb{$currentGate}\n";
		# $cin=getc(STDIN);
		
		###################################################################################
			
		$currentTh = $thValue;
		# if ( $probOfFailure{$currentGate} < $thValue ) { 
		if ( $POF < $thValue ) { 
			
			#------------------------------------------------------	
			#	Writing the final bench file by iterating through
			#	all the gates and based on their nType and pType
			#	variable values, apply suitable protection.
			#------------------------------------------------------	
			
			$newBenchFile = $inputFile."R_".$currentTh.".bench";	
			open (OUTPUT_Bench, ">$newBenchFile") or die $!;
			print OUTPUT_Bench "#Protection with Threshold of  ".((1-$currentTh)*100)."%\n";
			print OUTPUT_Bench "\n";
			print OUTPUT_Bench @IOs;
			print OUTPUT_Bench "\n";
			
			foreach $currentGate (@orderedGates) {
			
				@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.			
				$gateName = $inputs[0]; 	 
				
				if (($protType{$currentGate} == 20 )) { # or (grep {$_ eq $currentGate} @primaryOutputs)) {						
					print OUTPUT_Bench "$currentGate = D".$gateName."(";							
					for ($ii = 1; $ii < scalar @inputs; $ii++) {					
						if ($ii  == scalar @inputs - 1)	
						{	print OUTPUT_Bench "$inputs[$ii])\n";	}
						else
						{	print OUTPUT_Bench "$inputs[$ii], ";	}											
					}											
				}
				elsif (($protType{$currentGate} > 0 and $protType{$currentGate} < 9)) {
					print OUTPUT_Bench "$currentGate = $inputs[0]".(scalar @inputs -1)."$protType{$currentGate}(";								
					for ($ii = 1; $ii < scalar @inputs; $ii++) {					
						if ($ii  == scalar @inputs -1) {
							print OUTPUT_Bench "$inputs[$ii])\n";	
						}
						else {
							print OUTPUT_Bench "$inputs[$ii], ";	
						}
					}					
				}		
				elsif ($protType{$currentGate} == 0 ) { 
					print OUTPUT_Bench "$currentGate = $gateName(";							
					for ($ii = 1; $ii < scalar @inputs; $ii++) {					
						if ($ii  == scalar @inputs - 1)	
						{	print OUTPUT_Bench "$inputs[$ii])\n";	}
						else
						{	print OUTPUT_Bench "$inputs[$ii], ";	}											
					}											
				}		
				else {
					print OUTPUT_Bench $_;	
				}	
				
				if (grep $_ eq $currentGate, @primaryOutputs) {
				print OUTPUT_Bench "\n";
				}
			}
			
			print OUTPUT_Bench "END\n";
			close(OUTPUT_Bench);	
			#-------------------------------------------------------------
			
			$currentTh = shift(@ths);
		}
	}
	
	my $run_time = Time::HiRes::tv_interval($start_time);
	print "\tTime taken to create Bench File = $run_time sec.\n";	
	print LOG "\n\tTime taken = $run_time sec.\n";	
			
	close(LOG);
	
	open (AREA, ">>areas.txt") or die $!;
	print AREA "$circuitArea\n";
	close (AREA);
}
#######################################################

sub selectionAlgorithm_SymmetricScaling_ZhouPaper2{
	
	my $thValue = $_[0];
			
	my @orderedGates = ();
	my @sensitiveNodes = ();
	my @processedNodes = ();
	my @IOs = ();
	my %outBenchFile = ();
	my %probOfFailure = ();
	my %probOfFailure_COPY = ();
	my %detectionProb = ();
	my %strikeProb = ();
	my %protType = ();	
	my %gateConts_0 = ();
	my %gateConts_1 = ();
	my %currentCircuitGateAreas = ();	
	my %nodeAreas = ();
	my %collapsedFaultProb = ();
	my $currentArea = 0;
	my $currentNT = 0;
	my $targetArea = 0;
	
	my $verbosity = 0;
		
		
	my @ths = qw ($thValue);
	
	my $start_time = [Time::HiRes::gettimeofday()];	
	
	$nmosDrainArea = 0.09;
	$pmosDrainArea = 0.18;
	
	################################################
	# Get Area of current Circuit
	###############################################
	system ("perl bench_to_spice_45nm.pl $inputFile 1");
	open(IN,"area.sp") || die " Cannot open input file area.sp \n";
	$circuitArea=0;	# area of circuit
	while(<IN>){
		$circuitArea = $_;
	}
	close(IN);
	system ("del area.sp");
	system ("del $inputFile.sp");

	
	#---------------------------------------------------#
	#	Save each gate in the circuit along with 		#
	#   the prob. of failure of each transistor			# 
	#	in HASH structure. 								#
	#---------------------------------------------------#
	open (INPUT_FILE, $benchFile) or die $!;	
	while (<INPUT_FILE>) {	
		if (/=/) {				
			my @gateList = split(" = ", $_);
			$gateList[1] = "= ".$gateList[1];			
						
			$currentGate = $gateList[0];				
			$outBenchFile{$currentGate} = $gateList[1];		
			push @orderedGates, $currentGate;
			
			$protType{$currentGate} = 0;
			
			#-----------------------------------------------------------#
			#	Compute Probability of failure of each transistor of	#
			#	the current selected gate.								#
			#-----------------------------------------------------------#
			
			#-------------------------------------------------
			#Generate the remaining parts of final bench file
			#-------------------------------------------------			
			@gateList = ($_ =~ m/(\w+)/g);				
			$gateName[0] = $gateList[1];			
			@gateList = ($gateList[0], @gateList[2..$#gateList]);		

			$currentGate = $gateList[0];	
			@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.	
			$gateName = $inputs[0]; 	
			
			$currentCircuitGateAreas{$currentGate} = $gateArea_Zhou{$gateName.(scalar @inputs-1)};
			
			my $errorType = -1;
			my $gateType = ();
						
			$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate}/$numberOfTestVectors);
			$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate}/$numberOfTestVectors);	

			$collapsedFaultProb{$currentGate} = $sa0 + $sa1;						
			
		}		
		elsif ($_ =~ /INPUT|OUTPUT/) {
			push @IOs, $_;
		}
	} #End of Main while loop
	close(INPUT_FILE); 
	#############################################################
		
	open (LOG, ">$inputFile.$thValue.log") or die $!;
	
	#Sort the gates according to their prob. of failure
	@sensitiveGates = ();
	$GS = 0;
	$GC = 0;
	$coverage = 0;
	foreach my $name (sort { $collapsedFaultProb{$b} <=> $collapsedFaultProb{$a} } keys %collapsedFaultProb) {					
		push @sensitiveGates, $name;	
		$GS += $collapsedFaultProb{$name};	
	}	
	
	$coverage = ($GC/$GS)*100;
		
	printf "==>GC = %0.2f, GS = %0.2f, Coverage = %0.2f, Area = $circuitArea, TH = %d%%, Gates =  %d\n\n", $GC, $GS, $coverage, (1-$thValue)*100, scalar @sensitiveGates;		
	
	# print Dumper \%collapsedFaultProb; 
	# print Dumper @sensitiveGates; 	
	# exit;
	################################################################   

	#-------------------------------------------------------------#				 	
	print (LOG "************************************\n");  
	print (LOG "PROCESSING $inputFile ...\n\n");  
	printf(LOG "==>Initial Coverage = %0.4f, Area = $circuitArea, TH = %d%%, Total Gates =  %d\n", $coverage, (1-$thValue)*100, scalar @sensitiveGates);		
	#************************************************************************
	#	Protection Code Starts from here
	#************************************************************************
	
	%areaOH = ();
		
	$currentGate = shift(@sensitiveGates);
	# print "\nCurrent Gate = $currentGate, Coverage = $coverage\n";
		
	while ($coverage < (1-$thValue)*100) {											
		
		if (!(grep {$_ eq $currentGate} @sensitiveGates)) {
			push @sensitiveGates, $currentGate;
		}
					
		@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.										
		$gateName = $inputs[0]; 			
		
		$protectionType = 20;
		$protType{$currentGate} = 20;
		$collapsedFaultProb{$currentGate} = 0;
		
		$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate}/$numberOfTestVectors);
		$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate}/$numberOfTestVectors);			
		$GC += $sa0 + $sa1;		
		$coverage = ($GC/$GS)*100;
		
		# protecting the type e.g. NAND21, NAND32, NAND43 etc.
		$redundancyModel	=	$gateName.(scalar @inputs - 1).$protectionType;		 

		#Update Circuit Area
		$newArea = sprintf("%0.3f", $gateArea_Zhou{$redundancyModel});
		$oldArea = sprintf("%0.3f", $currentCircuitGateAreas{$currentGate});
		$overHead = sprintf("%0.3f", $newArea - $oldArea);				
		$circuitArea += sprintf("%0.3f", $overHead);
		
		$currentCircuitGateAreas{$currentGate} +=  $overHead;
		$areaOH{$currentGate} = $overHead;
				
				
		printf(LOG "Gate = $currentGate, Coverage = %0.4f, Area = $circuitArea\n", $coverage);		
		
		printf(">Gate = $currentGate, Coverage = %0.4f, Area = $circuitArea\n", $coverage);			
		
		$currentGate = shift(@sensitiveGates);	
				
		# print "\n==>Next Gate = $currentGate, Coverage = $coverage\n";
		# $cin=getc(STDIN);
		
		###################################################################################
			
		$currentTh = $thValue;
		if ( $coverage >= (1-$thValue)*100) { 
			
			#------------------------------------------------------	
			#	Writing the final bench file by iterating through
			#	all the gates and based on their nType and pType
			#	variable values, apply suitable protection.
			#------------------------------------------------------	
			
			$newBenchFile = $inputFile."R_".$currentTh.".bench";	
			open (OUTPUT_Bench, ">$newBenchFile") or die $!;
			print OUTPUT_Bench "#Protection with Threshold of  ".((1-$currentTh)*100)."%\n";
			print OUTPUT_Bench "\n";
			print OUTPUT_Bench @IOs;
			print OUTPUT_Bench "\n";
			
			foreach $currentGate (@orderedGates) {
			
				@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.			
				$gateName = $inputs[0]; 	 
				
				if (($protType{$currentGate} == 20 )) { 
					print OUTPUT_Bench "$currentGate = D".$gateName."(";							
					for ($ii = 1; $ii < scalar @inputs; $ii++) {					
						if ($ii  == scalar @inputs - 1)	
						{	print OUTPUT_Bench "$inputs[$ii])\n";	}
						else
						{	print OUTPUT_Bench "$inputs[$ii], ";	}											
					}											
				}
				elsif ($protType{$currentGate} == 0 ) { 
					print OUTPUT_Bench "$currentGate = $gateName(";							
					for ($ii = 1; $ii < scalar @inputs; $ii++) {					
						if ($ii  == scalar @inputs - 1)	
						{	print OUTPUT_Bench "$inputs[$ii])\n";	}
						else
						{	print OUTPUT_Bench "$inputs[$ii], ";	}											
					}											
				}		
				else {
					print OUTPUT_Bench $_;	
				}	
				
				if (grep $_ eq $currentGate, @primaryOutputs) {
				print OUTPUT_Bench "\n";
				}
			}
			
			print OUTPUT_Bench "END\n";
			close(OUTPUT_Bench);	
			#-------------------------------------------------------------
			
			$currentTh = shift(@ths);
		}
	}
	
	my $run_time = Time::HiRes::tv_interval($start_time);
	print "\tTime taken to create Bench File = $run_time sec.\n";	
	print LOG "\n\tTime taken = $run_time sec.\n";		
	
	close(LOG);
	
	open (AREA, ">>areas.txt") or die $!;
	print AREA "$circuitArea\n";
	close (AREA);
}
#######################################################

sub Lazzari_PAPER{
	
	my $thValue = $_[0];
	
			
	my @orderedGates = ();
	my @sensitiveNodes = ();
	my @processedNodes = ();
	my @IOs = ();
	my %outBenchFile = ();
	my %probOfFailure = ();
	my %probOfFailure_COPY = ();
	my %detectionProb = ();
	my %strikeProb = ();
	my %protType = ();	
	my %gateConts_0 = ();
	my %gateConts_1 = ();
	my %currentCircuitGateAreas = ();	
	my %nodeAreas = ();
	my %collapsedFaultProb = ();
	my $currentArea = 0;
	my $currentNT = 0;
	my $targetArea = 0;
	
	my $verbosity = 0;
		
	%ipp = %{retrieve($inputFile.'.ipp')};
	%tech = %{retrieve('130nm.pf')};
	# print Dumper \%ipp;
	
	my @ths = qw ($thValue);
	
	my $start_time = [Time::HiRes::gettimeofday()];	
	
	$nmosDrainArea = 0.26;
	$pmosDrainArea = 0.52;
	
	################################################
	# Get Area of current Circuit
	###############################################
	system ("perl bench_to_spice_130nm.pl $inputFile 1");
	open(IN,"area.sp") || die " Cannot open input file area.sp \n";
	$circuitArea=0;	# area of circuit
	while(<IN>){
		$circuitArea = $_;
	}
	close(IN);
	system ("del area.sp");
	system ("del $inputFile.sp");
			
	#############################################################
	#	Read the Propagation Stats file of current circuit.		#
	#############################################################
	my %currentCircuitPropFailureProbs = ();
	$propFile = $inputFile.".prop";
	
	open (PROP_IN, $propFile) or die $!;
	while(<PROP_IN>) {
		chomp;
		@row = split('=>', $_);
		$currentCircuitPropFailureProbs{$row[0]} = $row[1];		
	}
	close(PROP_IN);	
	#############################################################
	
	#---------------------------------------------------#
	#	Save each gate in the circuit along with 		#
	#   the prob. of failure of each transistor			# 
	#	in HASH structure. 								#
	#---------------------------------------------------#
	open (INPUT_FILE, $benchFile) or die $!;	
	while (<INPUT_FILE>) {	
		if (/=/) {				
			my @gateList = split(" = ", $_);
			$gateList[1] = "= ".$gateList[1];			
						
			$currentGate = $gateList[0];				
			$outBenchFile{$currentGate} = $gateList[1];		
			push @orderedGates, $currentGate;
			
			$protType{$currentGate} = 0; #Initialize the protection type of each senstive gate to 0			
			
			#-----------------------------------------------------------#
			#	Compute Probability of failure of each transistor of	#
			#	the current selected gate.								#
			#-----------------------------------------------------------#
			
			#-------------------------------------------------
			#Generate the remaining parts of final bench file
			#-------------------------------------------------			
			@gateList = ($_ =~ m/(\w+)/g);				
			$gateType[0] = $gateList[1];			
			@gateList = ($gateList[0], @gateList[2..$#gateList]);		

			$currentGate = $gateList[0];	
			@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.	
			$gateType = $inputs[0]; 	
			
			$currentCircuitGateAreas{$currentGate} = $gateArea_130nm{$gateType.(scalar @inputs-1)};
			
			my $errorType = -1;
									
			$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate}/$numberOfTestVectors);
			$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate}/$numberOfTestVectors);	

			$collapsedFaultProb{$currentGate."-sa0"} = $sa0;
			$collapsedFaultProb{$currentGate."-sa1"} = $sa1;
								
			# process the Gates			
			my $nType = 0;
			my $pType = 0;
			my $nmos = 0;
			my $pmos = 0;			
				
			#iterate through all the N-type and P-Type transistors.
			for ($ii = 1; $ii < scalar @inputs; $ii++) {
				$nmos = "N".$ii;
				$pmos = "P".$ii;					
				
				#Compute gate controllability from the .ipp file, only once for each gate
				if ($ii==1) {
				
					#FOR NMOS
					# Read the generic failed vectors for N1
					@failedVectors = ();
					$nmos1 = $gateType.(scalar @inputs - 1)."-N$ii";						
					
					for $vector ( keys %{ $tech{$nmos1} } ) {
						push @failedVectors, $vector;						
					}										
				
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$currentGate} } ) {
						push @currentFailedVectors, $vector;						
					}
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
					
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 							
					}
					$gateConts_1{$currentGate} = $freq;
						
					#FOR PMOS
					# Read the generic failed vectors for P-Type
					@failedVectors = ();	
					$pmos1 = $gateType.(scalar @inputs - 1)."-P$ii";	
										
					for $vector ( keys %{ $tech{$pmos1} } ) {
						push @failedVectors, $vector;						
					}					
					
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$currentGate} } ) {
						push @currentFailedVectors, $vector;						
					}				
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
				
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 
					}
					$gateConts_0{$currentGate} = $freq;
					
					if ($gateConts_1{$currentGate}==0) {	$gateConts_1{$currentGate} = 1;	}
					if ($gateConts_0{$currentGate}==0) {	$gateConts_0{$currentGate} = 1;	}					
				}				
								
				$currentNode_N = $currentGate."-$nmos";
				$currentNode_P = $currentGate."-$pmos";
				
				if ($currentCircuitPropFailureProbs{$currentNode_N}*$sa0 > 0) {
					$detectionProb{$currentNode_N}	=	$currentCircuitPropFailureProbs{$currentNode_N}*$sa0/$gateConts_1{$currentGate};
					$strikeProb{$currentNode_N} 	=	$nmosDrainArea/$circuitArea;
					$nodeAreas{$currentNode_N} = $nmosDrainArea;
					$probOfFailure{$currentNode_N}	= 	$detectionProb{$currentNode_N}*$strikeProb{$currentNode_N};					
				}
				else {
					$detectionProb{$currentNode_N}	= 0;					
					$probOfFailure{$currentNode_N} = 0;						
					$nodeAreas{$currentNode_N} = $nmosDrainArea;
				}
								
				if ($currentCircuitPropFailureProbs{$currentNode_P}*$sa1 > 0) {
					$detectionProb{$currentNode_P}	=	$currentCircuitPropFailureProbs{$currentNode_P}*$sa1/$gateConts_0{$currentGate};
					$strikeProb{$currentNode_P} 	=	$pmosDrainArea/$circuitArea;
					$nodeAreas{$currentNode_P} = $pmosDrainArea;
					$probOfFailure{$currentNode_P}	= 	$detectionProb{$currentNode_P}*$strikeProb{$currentNode_P};					
				}
				else {
					$detectionProb{$currentNode_P}	= 0;
					$probOfFailure{$currentNode_P}  = 0;
					$nodeAreas{$currentNode_P} = $pmosDrainArea;
				}								
				# if ($currentGate eq "g" or $verbosity == 1) {
					# print "Current Gate = $currentGate, inputs = @inputs, $nmos1 Area = $nmosDrainArea, $pmos1 Area = $pmosDrainArea, Total Area = $circuitArea\n";
					# print "Node = $currentNode_N, Prob SA0 = $sa0, PC1 = $gateConts_1{$currentGate}, IPP = $currentCircuitPropFailureProbs{$currentNode_N}\n";
					# print "$currentNode_N: DET = $detectionProb{$currentNode_N}, Strike = $strikeProb{$currentNode_N},  POF $nmos = $probOfFailure{$currentNode_N}\n\n";					
					# print "Node = $currentNode_P, Prob SA1 = $sa1, PC0 = $gateConts_0{$currentGate}, IPP = $currentCircuitPropFailureProbs{$currentNode_P}\n";
					# print "$currentNode_P: DET = $detectionProb{$currentNode_P}, Strike = $strikeProb{$currentNode_P},  POF $pmos = $probOfFailure{$currentNode_P}\n\n";			
				# }				
			}					
		}		
		elsif ($_ =~ /INPUT|OUTPUT/) {
			push @IOs, $_;
		}
	} #End of Main while loop
	close(INPUT_FILE);
	#############################################################
		
	open (LOG, ">$inputFile.$thValue.log") or die $!;
	
	#Sort the gates according to their prob. of failure
	@sensitiveGates = ();
	foreach my $name (sort { $collapsedFaultProb{$b} <=> $collapsedFaultProb{$a} } keys %collapsedFaultProb) {					
		push @sensitiveGates, $name;	
		print "N = $name, Sens = $collapsedFaultProb{$name}\n";	
	}	
	
	# print Dumper \%collapsedFaultProb; 
	# print Dumper @sensitiveGates; 
	# exit;
	
	
	@sensitiveNodes = ();
	$POF = 0;		 
	foreach my $name (sort { $probOfFailure{$b} <=> $probOfFailure{$a} or $a cmp $b } keys %probOfFailure) {					
		push @sensitiveNodes, $name;	
		$POF += $probOfFailure{$name};		
		# print "N = $name, POF = $probOfFailure{$name}\n";
	}	
	$totalNodes = scalar @sensitiveNodes;
	$circuitArea = sprintf("%0.3f", $circuitArea);
	$targetArea = $circuitArea + ($circuitArea*$thValue);	
	
	printf "==>Initial POF = %0.4f, Area = $circuitArea, TH = %0.4f, Total Nodes = $totalNodes\n", $POF*100, $thValue*100;		
	%POF_ORIGINAL =  %{ dclone(\%probOfFailure) };		
	#############################################################
   

	#-------------------------------------------------------------#				
	
	print (LOG "************************************\n");  
	print (LOG "PROCESSING $inputFile ...\n\n");  
	printf (LOG "==>POF = %0.4f, Area = %0.4f, Total Nodes = %d, TH = %0.4f\n",$POF*100, $circuitArea, scalar @sensitiveNodes, $thValue*100);
	
	#************************************************************************
	#	Protection Code Starts from here
	#************************************************************************
	@allNodes = @{ dclone(\@sensitiveNodes) }; 	
	%areaOH = ();
		
	$crg = "g212-P1";	
	$currentNode = shift(@sensitiveGates);
	@t = split("-", $currentNode);
	$currentGate = $t[0];
	$toProt = $t[1];
	# print "\nCN: $currentNode, Current Gate = $currentGate, toProt: $toProt\n"; exit;
	
	$flag = 0;	
	$currentNodePOF = 0;			
	@sensitiveGates = ();
	
	while ($POF > $thValue) {											
	# while ($circuitArea < $targetArea and $POF > 0) {											
		
		if (!(grep {$_ eq $currentGate} @sensitiveGates)) {
			push @sensitiveGates, $currentGate."-$toProt";
		}
					
		@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.										
		$gateType = $inputs[0]; 
		$ins = scalar @inputs - 1;
								
		if ($gateType eq "NAND") {
			$protectionType = getProtectionTypeNAND_Lazzari($protType{$currentGate}, $toProt, $ins);						
		}
		elsif ($gateType eq "NOR") {
			$protectionType = getProtectionTypeNOR_Lazzari($protType{$currentGate}, $toProt, $ins);		
		}		
		elsif ($gateType eq "NOT") {
			$protectionType = getProtectionTypeNOT_Lazzari($protType{$currentGate}, $toProt, $ins);									
		}	
		
		
		$collapsedFaultProb{$currentGate."-$toProt"} = 0;
		
		# print "CG: $currentGate, Name: $gateType, @inputs, Prot: $protectionType, toProt: $toProt\n"; $cin=getc(STDIN);
		
		# protecting the type e.g., NAND21, NAND32, NAND43 etc.
		$redundancyModel	=	$gateType.(scalar @inputs - 1).$protectionType;		 

		#Update Circuit Area
		$newArea = sprintf("%0.3f", $gateArea_130nm{$redundancyModel});
		$oldArea = sprintf("%0.3f", $currentCircuitGateAreas{$currentGate});
		$overHead = sprintf("%0.3f", $newArea - $oldArea);				
		$circuitArea += sprintf("%0.3f", $overHead);
		$protType{$currentGate} = $protectionType;			
		$currentCircuitGateAreas{$currentGate} +=  $overHead;
		$areaOH{$currentGate} = $overHead;
				
		# if ($flag==1) {
			# print "CN: $currentGate, Gate Area = $currentCircuitGateAreas{$currentGate}, New AREA = $gateArea_130nm{$redundancyModel}, OH = $overHead, OA = $oldArea\n";
		# }
			
		@nodesToUpdate = ();
		if ($gateType eq "NAND") {
			
			push @nodesToUpdate, $currentGate."-N1";								
			for $kk (1..scalar @inputs -1) {
				push @nodesToUpdate, $currentGate."-P$kk";					
			}			
		}
		elsif ($gateType eq "NOR") {
			
			push @nodesToUpdate, $currentGate."-P1";								
			for $kk (1..scalar @inputs -1) {
				push @nodesToUpdate, $currentGate."-N$kk";					
			}			
		}		
		elsif ($gateType eq "NOT") {				
			push @nodesToUpdate, $currentGate."-N1";
			push @nodesToUpdate, $currentGate."-P1";						
		}
		
		# print "CG: $currentGate, Name: $gateType, @inputs, Prot: $protectionType, N-UP: @nodesToUpdate\n"; $cin=getc(STDIN);
		
		# if ($currentGate eq "g212-P1") {
			# print "\n*******************************************************************************\n";
			# print "Protection Algorithm starting to protect $currentGate\n";
			# print "*******************************************************************************\n";
			# print "====>Current Node = $currentGate, POF = ".($probOfFailure{$currentGate}*100).", Area = $circuitArea, AREA OH = $areaOH{$currentGate}, Prev Area = ",($circuitArea-$overHead),", Prot Type = $protType{$currentGate}\n\n";		
		# } 
				
		
		# Iterate through the transistors list to update their POFs	
		foreach my $node (@allNodes) {

			@failedVectors = ();	

			@row = split("-", $node);				
			$CG = $row[0];
			$cType = $row[1]; # i.e. nmos or pmos	
									
			if (grep {$_ eq $node} @nodesToUpdate) {
				if ($protectionType == 20) { # FULLY PROTECTED CASE, make POFs of transistors of $currentGate to zero
					$probOfFailure{$node}	= 	0;	
					$detectionProb{$node} = 	0;
					$nodeAreas{$node} = $transArea_130nm{$redundancyModel."-$cType"};
				}
				else {
					$trans = $redundancyModel."-$cType";					
					
					for $vector ( keys %{ $tech{$trans} } ) {
						push @failedVectors, $vector;						
					}					
			
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$CG} } ) {
						push @currentFailedVectors, $vector;						
					}
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
													
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 
					}
					
					$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate}/$numberOfTestVectors);
					$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate}/$numberOfTestVectors);									
						
					$drainArea = $transArea_130nm{$trans};	
					$nodeAreas{$node} = $drainArea;
									
					$gateContProb = 0;
					$stuckAtProb = 0;
					
					if ($cType =~ m/N/i) {
						$gateContProb = $gateConts_1{$CG};
						$stuckAtProb = $sa0;
					}
					else {
						$gateContProb = $gateConts_0{$CG};
						$stuckAtProb = $sa1;
					}
					
					$detectionProb{$node}	=	($freq*$stuckAtProb)/$gateContProb;
					$strikeProb{$node} 	=	$drainArea/$circuitArea;
					$probOfFailure{$node}	= 	$detectionProb{$node}*$strikeProb{$node};					
				}
				# if (($currentGate eq "g212-P1" and $flag==1) or $verbosity ==1) {
					# print "Node = $node, protType = $protectionType,  CG = $currentGate, $trans Area = $drainArea, Total Area = $circuitArea\n";
					# print "Prob SA0 = $sa0, SA1 = $sa1, PC0 = $gateConts_0{$currentGate}, PC1 = $gateConts_1{$currentGate}, IPP = $currentCircuitPropFailureProbs{$node}\n";		
					# print "Failed Vecs. = @failedVectors\n";
					# print "Current IPP = @currentFailedVectors\nCommon = @isect\n";						
					# print "Node = $node: FREQ=$freq, DET = ",$detectionProb{$node}," HIT = ",$strikeProb{$node}," Trans-Area = $drainArea, POF $node = ",$probOfFailure{$node}*100,"\n\n";
				# }		
			}
			else {
				$drainArea = $nodeAreas{$node};				
				$strikeProb{$node} 	=	$drainArea/$circuitArea;					
				$probOfFailure{$node}	= 	$detectionProb{$node}*$strikeProb{$node};					
				
				# if ($currentGate eq "v" or $verbosity ==1) {
					# print "::Node = $node: DET = $detectionProb{$node}, HIT = $strikeProb{$node}, Trans-Area = $drainArea, POF $node = $probOfFailure{$node}\n";	
				# }
			}			
		}								
		###############################################################################
	
		$NEWPOF = 0;
		foreach my $name (@allNodes) {				
			$NEWPOF += $probOfFailure{$name};										
		}	
		# $NEWPOF += 0.0015;
		
		# printf (LOG "POF = %0.6f\n", $NEWPOF*100);			
		
		printf (LOG ">CIRC POF= %0.4f, Area= %.4f, CG= $currentGate ($gateType$ins), Prot: $protType{$currentGate}\n", $NEWPOF*100, $circuitArea);
		
		printf (">CIRC POF: %0.4f, Area: %.4f, CG: $currentGate ($gateType$ins), Prot: $protType{$currentGate}\n", $NEWPOF*100, $circuitArea);		
		
		@temp = ();
		foreach my $name (sort { $collapsedFaultProb{$b} <=> $collapsedFaultProb{$a} } keys %collapsedFaultProb) {
			if ($collapsedFaultProb{$name} > 0 and !(grep {$_ eq $name} @sensitiveGates)) {
				push @temp, $name;				
			}
			# print "Node = $name, POF = $collapsedFaultProb{$currentGate}\n";
		}		
		
		$currentNode = shift(@temp);
		@t = split("-", $currentNode);
		$currentGate = $t[0];
		$toProt = $t[1];
				
		$POF = $NEWPOF;		
		
		# print "\n==>Next Gate = $currentGate, POF-$currentNode = $collapsedFaultProb{$currentNode}\n";
		# print "TEMP: ",scalar @temp,"\n";
		# $cin=getc(STDIN);
				
		###################################################################################
			
		$currentTh = $thValue;
		# if ( $probOfFailure{$currentGate} < $thValue ) { 
		if ( ($POF < $thValue) or (scalar @temp == 0) ) { 
		# if ( $circuitArea >= $targetArea ) { 
		
			
			#------------------------------------------------------	
			#	Writing the final bench file by iterating through
			#	all the gates and based on their nType and pType
			#	variable values, apply suitable protection.
			#------------------------------------------------------	
			
			$newBenchFile = $inputFile."R_".$currentTh.".bench";	
			open (OUTPUT_Bench, ">$newBenchFile") or die $!;
			print OUTPUT_Bench "#Protection with Threshold of  ".((1-$currentTh)*100)."%\n";
			print OUTPUT_Bench "\n";
			print OUTPUT_Bench @IOs;
			print OUTPUT_Bench "\n";
			
			foreach $currentGate (@orderedGates) {
			
				@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.			
				$gateType = $inputs[0]; 	 
				
				if (($protType{$currentGate} == 20 )) { # or (grep {$_ eq $currentGate} @primaryOutputs)) {						
					print OUTPUT_Bench "$currentGate = D".$gateType."(";							
					for ($ii = 1; $ii < scalar @inputs; $ii++) {					
						if ($ii  == scalar @inputs - 1)	
						{	print OUTPUT_Bench "$inputs[$ii])\n";	}
						else
						{	print OUTPUT_Bench "$inputs[$ii], ";	}											
					}											
				}
				elsif (($protType{$currentGate} > 0 and $protType{$currentGate} < 9)) {
					print OUTPUT_Bench "$currentGate = $inputs[0]".(scalar @inputs -1)."$protType{$currentGate}(";								
					for ($ii = 1; $ii < scalar @inputs; $ii++) {					
						if ($ii  == scalar @inputs -1) {
							print OUTPUT_Bench "$inputs[$ii])\n";	
						}
						else {
							print OUTPUT_Bench "$inputs[$ii], ";	
						}
					}					
				}		
				elsif ($protType{$currentGate} == 0 ) { 
					print OUTPUT_Bench "$currentGate = $gateType(";							
					for ($ii = 1; $ii < scalar @inputs; $ii++) {					
						if ($ii  == scalar @inputs - 1)	
						{	print OUTPUT_Bench "$inputs[$ii])\n";	}
						else
						{	print OUTPUT_Bench "$inputs[$ii], ";	}											
					}											
				}		
				else {
					print OUTPUT_Bench $_;	
				}	
				
				if (grep $_ eq $currentGate, @primaryOutputs) {
				print OUTPUT_Bench "\n";
				}
			}
			
			print OUTPUT_Bench "END\n";
			close(OUTPUT_Bench);	
			#-------------------------------------------------------------
			
			$currentTh = shift(@ths);
			last;
		}		
	}
	
	my $run_time = Time::HiRes::tv_interval($start_time);
	print "\tTime taken to create Bench File = $run_time sec.\n";	
	print LOG "\n\tTime taken = $run_time sec.\n";	
		
	close(LOG);
	
	open (AREA, ">>areas.txt") or die $!;
	print AREA "$circuitArea\n";
	close (AREA);
	
}
#######################################################



#-----------------------------------------------
#		Main Program
#-----------------------------------------------

$cwd = getcwd; #get Current Working Directory
$inputFile = $ARGV[0]; #faults file generated by HOPE
$threshold  = $ARGV[1];  #error threshold or area overhead
# $threshold2  = $ARGV[2];  #error threshold or area overhead

#-----------------------------------------------
#		Variables Initialization
#-----------------------------------------------
%circuitFaults_1 = ();
%circuitFaults_0 = ();
%circuitFaults_original_1 = ();
%circuitFaults_original_0 = ();
$numberOfPrimaryInputs = 0;
$numberOfPrimaryOutputs = 0;
$numberOfCombGates = 0;
$numberOfFF = 0;
$numberOfLevels = 0;
$numberOfCollapsedFaults = 0;
$numberOfDetectedFaults = 0;
$numberOfUndetectedFaults = 0;

$faultCoverage = 0;
$replicationType = 0;
@testVectors = ();
@primaryOutputs = ();
@primaryInputs = ();
@inter_IO_Gates = ();
%listOfGates = ();
%completeGates = ();
%inputs = ();
%input2Output = ();
%isDuplicate = ();
%gatesCounter = ();
%gatePOF = ();

@moreThan4Inputs = 0;

#-----------------------------------------------
{
%gateArea_130nm = (	'NOT1'		=> '0.780',
				'NOT11'		=> '2.756',
				'NOT12'		=> '1.560',
				'NOT120'	=> '3.536',
				'NAND2'		=> '1.560',
				'NAND21'	=> '3.536',
				'NAND22'	=> '5.512',
				'NAND23'	=> '4.264',
				'NAND24'	=> '6.240',
				'NAND220'	=> '8.216',
				'NAND3'		=> '2.340',
				'NAND31'	=> '4.316',
				'NAND32'	=> '6.292',
				'NAND33'	=> '8.268',
				'NAND34'	=> '7.956',
				'NAND35'	=> '9.932',
				'NAND36'	=> '11.908',
				'NAND320'	=> '13.884',
				'NAND4'		=> '3.120',
				'NAND41'	=> '5.096',
				'NAND42'	=> '7.072',
				'NAND43'	=> '9.048',
				'NAND44'	=> '11.024',
				'NAND45'	=> '12.688',
				'NAND46'	=> '14.664',
				'NAND47'	=> '16.640',
				'NAND48'	=> '18.616',
				'NAND420'	=> '20.592',			
				'NOR2'		=> '1.560',
				'NOR21'		=> '2.340',
				'NOR22'		=> '3.120',
				'NOR23'		=> '9.672',
				'NOR24'		=> '10.452',
				'NOR220'	=> '11.232',
				'NOR3'		=> '2.340',
				'NOR31'		=> '3.120',
				'NOR32'		=> '3.900',
				'NOR33'		=> '4.680',
				'NOR34'		=> '20.124',
				'NOR35'		=> '20.904',
				'NOR36'		=> '21.684',
				'NOR320'	=> '22.464',
				'NOR4'		=> '3.120',
				'NOR41'		=> '3.900',
				'NOR42'		=> '4.680',
				'NOR43'		=> '5.460',
				'NOR44'		=> '6.240',
				'NOR45'		=> '32.240',
				'NOR46'		=> '33.020',
				'NOR47'		=> '33.800',
				'NOR48'		=> '34.580',
				'NOR420'	=> '35.360'
			);					
}


{
%gateArea_45nm = (	'NOT1'		=> '0.270',
				'NOT11'		=> '0.990',
				'NOT12'		=> '0.684',
				'NOT120'	=> '1.404',
				'NAND2'		=> '0.540',
				'NAND21'	=> '1.260',
				'NAND22'	=> '1.980',
				'NAND23'	=> '2.016',
				'NAND24'	=> '2.700',
				'NAND220'	=> '3.420',
				'NAND3'		=> '0.810',
				'NAND31'	=> '1.530',
				'NAND32'	=> '2.250',
				'NAND33'	=> '2.970',
				'NAND34'	=> '3.888',
				'NAND35'	=> '4.608',
				'NAND36'	=> '5.220',
				'NAND320'	=> '5.940',
				'NAND4'		=> '1.080',
				'NAND41'	=> '1.800',
				'NAND42'	=> '2.520',
				'NAND43'	=> '3.240',
				'NAND44'	=> '3.960',
				'NAND45'	=> '6.120',
				'NAND46'	=> '6.840',
				'NAND47'	=> '7.560',
				'NAND48'	=> '7.956',
				'NAND420'	=> '8.676',				
				'NOR2'		=> '0.540',
				'NOR21'		=> '0.954',
				'NOR22'		=> '1.368',
				'NOR23'		=> '4.500',
				'NOR24'		=> '4.914',
				'NOR220'	=> '5.328',
				'NOR3'		=> '0.810',
				'NOR31'		=> '1.224',
				'NOR32'		=> '1.638',
				'NOR33'		=> '2.052',
				'NOR34'		=> '9.450',
				'NOR35'		=> '9.864',
				'NOR36'		=> '10.278',
				'NOR320'	=> '10.692',
				'NOR4'		=> '1.080',
				'NOR41'		=> '1.494',
				'NOR42'		=> '1.908',
				'NOR43'		=> '2.322',
				'NOR44'		=> '2.736',
				'NOR45'		=> '16.776',
				'NOR46'		=> '17.190',
				'NOR47'		=> '17.604',
				'NOR48'		=> '18.018',
				'NOR420'	=> '18.144'
			);					
}


{
%gateArea_Zhou_45nm = (	
					'NOT1'		=> '0.270',
					'NOT11'		=> '0.990',
					'NOT12'		=> '0.684',
					'NAND2'		=> '0.540',
					'NAND21'	=> '1.260',
					'NAND22'	=> '1.980',
					'NAND23'	=> '2.016',
					'NAND24'	=> '2.700',
					'NAND3'		=> '0.810',
					'NAND31'	=> '1.530',
					'NAND32'	=> '2.250',
					'NAND33'	=> '2.970',
					'NAND34'	=> '3.888',
					'NAND35'	=> '4.608',
					'NAND36'	=> '5.220',
					'NAND4'		=> '1.080',
					'NAND41'	=> '1.800',
					'NAND42'	=> '2.520',
					'NAND43'	=> '3.240',
					'NAND44'	=> '3.960',
					'NAND45'	=> '6.120',
					'NAND46'	=> '6.840',
					'NAND47'	=> '7.560',
					'NAND48'	=> '7.956',
					'NOR2'		=> '0.540',
					'NOR21'		=> '0.954',
					'NOR22'		=> '1.368',
					'NOR23'		=> '4.500',
					'NOR24'		=> '4.914',
					'NOR3'		=> '0.810',
					'NOR31'		=> '1.224',
					'NOR32'		=> '1.638',
					'NOR33'		=> '2.052',
					'NOR34'		=> '9.450',
					'NOR35'		=> '9.864',
					'NOR36'		=> '10.278',
					'NOR4'		=> '1.080',
					'NOR41'		=> '1.494',
					'NOR42'		=> '1.908',
					'NOR43'		=> '2.322',
					'NOR44'		=> '2.736',
					'NOR45'		=> '16.776',
					'NOR46'		=> '17.190',
					'NOR47'		=> '17.604',
					'NOR48'		=> '18.018',
					'NOT120'	=> '1.512',
					'NAND220'	=> '4.860',
					'NAND320'	=> '9.720',
					'NAND420'	=> '15.228',				
					'NOR220'	=> '6.480',
					'NOR320'	=> '13.770',
					'NOR420'	=> '24.192'
			);					
}


{
%gateArea_Zhou_130nm = (	'NOT1'		=> '0.780',
				'NOT11'		=> '2.756',
				'NOT12'		=> '1.560',
				'NOT120'	=> '3.744',
				'NAND2'		=> '1.560',
				'NAND21'	=> '3.536',
				'NAND22'	=> '5.512',
				'NAND23'	=> '4.264',
				'NAND24'	=> '6.240',
				'NAND220'	=> '9.672',
				'NAND3'		=> '2.340',
				'NAND31'	=> '4.316',
				'NAND32'	=> '6.292',
				'NAND33'	=> '8.268',
				'NAND34'	=> '7.956',
				'NAND35'	=> '9.932',
				'NAND36'	=> '11.908',
				'NAND320'	=> '19.188',
				'NAND4'		=> '3.120',
				'NAND41'	=> '5.096',
				'NAND42'	=> '7.072',
				'NAND43'	=> '9.048',
				'NAND44'	=> '11.024',
				'NAND45'	=> '12.688',
				'NAND46'	=> '14.664',
				'NAND47'	=> '16.640',
				'NAND48'	=> '18.616',
				'NAND420'	=> '31.824',			
				'NOR2'		=> '1.560',
				'NOR21'		=> '2.340',
				'NOR22'		=> '3.120',
				'NOR23'		=> '9.672',
				'NOR24'		=> '10.452',
				'NOR220'	=> '13.728',
				'NOR3'		=> '2.340',
				'NOR31'		=> '3.120',
				'NOR32'		=> '3.900',
				'NOR33'		=> '4.680',
				'NOR34'		=> '20.124',
				'NOR35'		=> '20.904',
				'NOR36'		=> '21.684',
				'NOR320'	=> '29.016',
				'NOR4'		=> '3.120',
				'NOR41'		=> '3.900',
				'NOR42'		=> '4.680',
				'NOR43'		=> '5.460',
				'NOR44'		=> '6.240',
				'NOR45'		=> '32.240',
				'NOR46'		=> '33.020',
				'NOR47'		=> '33.800',
				'NOR48'		=> '34.580',
				'NOR420'	=> '46.800'
			);					
}


{
%transArea_130nm = ('NOT11-N1'	=>	'0.26', 
					'NOT11-P1'	=>	'2.496',		
					'NOT12-N1'	=>	'1.040', 
					'NOT12-P1'	=>	'0.520',					
					'NOT120-N1'	=>	'1.040',						
					'NOT120-P1'	=>	'2.496',					
					'NAND21-N1'  =>	'0.26',						
					'NAND21-N2'  =>	'0.26',						
					'NAND21-P1'  =>	'2.496',								
					'NAND21-P2'  =>	'0.52',	
					'NAND22-N1'  =>	'0.26',						
					'NAND22-N2'  =>	'0.26',						
					'NAND22-P1'  =>	'2.496',								
					'NAND22-P2'  =>	'2.496',
					'NAND23-N1'  =>	'1.612',						
					'NAND23-N2'  =>	'1.612',						
					'NAND23-P1'  =>	'0.52',										
					'NAND23-P2'  =>	'0.52',	
					'NAND24-N1'  =>	'1.612',					
					'NAND24-N2'  =>	'1.612',					
					'NAND24-P1'  =>	'2.496',								
					'NAND24-P2'  =>	'0.52',	
					'NAND220-N1'  =>	'1.612',
					'NAND220-N2'  =>	'1.612',
					'NAND220-P1'  =>	'2.496',
					'NAND220-P2'  =>	'2.496',					
					'NAND31-N1'  =>	'0.26',						
					'NAND31-N2'  =>	'0.26',						
					'NAND31-N3'  =>	'0.26',						
					'NAND31-P1'  =>	'2.496',								
					'NAND31-P2'  =>	'0.52',		
					'NAND31-P3'  =>	'0.52',
					'NAND32-N1'  =>	'0.26',						
					'NAND32-N2'  =>	'0.26',						
					'NAND32-N3'  =>	'0.26',						
					'NAND32-P1'  =>	'2.496',								
					'NAND32-P2'  =>	'2.496',
					'NAND32-P3'  =>	'0.52',						
					'NAND33-N1'  =>	'0.26',						
					'NAND33-N2'  =>	'0.26',						
					'NAND33-N3'  =>	'0.26',						
					'NAND33-P1'  =>	'2.496',								
					'NAND33-P2'  =>	'2.496',
					'NAND33-P3'  =>	'2.496',
					'NAND34-N1'  =>	'2.131',						
					'NAND34-N2'  =>	'2.132',						
					'NAND34-N3'  =>	'2.132',						
					'NAND34-P1'  =>	'0.52',										
					'NAND34-P2'  =>	'0.52',		
					'NAND34-P3'  =>	'0.52',				
					'NAND35-N1'  =>	'2.132',						
					'NAND35-N2'  =>	'2.132',						
					'NAND35-N3'  =>	'2.132',						
					'NAND35-P1'  =>	'2.496',								
					'NAND35-P2'  =>	'0.52',	
					'NAND35-P3'  =>	'0.52',				
					'NAND36-N1'  =>	'2.132',					
					'NAND36-N2'  =>	'2.132',					
					'NAND36-N3'  =>	'2.132',					
					'NAND36-P1'  =>	'2.496',								
					'NAND36-P2'  =>	'2.496',
					'NAND36-P3'  =>	'0.52',	
					'NAND320-N1'  =>	'2.132',
					'NAND320-N2'  =>	'2.132',
					'NAND320-N3'  =>	'2.132',
					'NAND320-P1'  =>	'2.496',
					'NAND320-P2'  =>	'2.496',
					'NAND320-P3'  =>	'2.496',					
					'NAND41-N1'  =>	'0.26',						
					'NAND41-N2'  =>	'0.26',						
					'NAND41-N3'  =>	'0.26',						
					'NAND41-N4'  =>	'0.26',						
					'NAND41-P1'  =>	'2.496',								
					'NAND41-P2'  =>	'0.52',		
					'NAND41-P3'  =>	'0.52',
					'NAND41-P4'  =>	'0.52',					
					'NAND42-N1'  =>	'0.26',						
					'NAND42-N2'  =>	'0.26',						
					'NAND42-N3'  =>	'0.26',						
					'NAND42-N4'  =>	'0.26',						
					'NAND42-P1'  =>	'2.496',								
					'NAND42-P2'  =>	'2.496',
					'NAND42-P3'  =>	'0.52',
					'NAND42-P4'  =>	'0.52',					
					'NAND43-N1'  =>	'0.26',						
					'NAND43-N2'  =>	'0.26',						
					'NAND43-N3'  =>	'0.26',						
					'NAND43-N4'  =>	'0.26',						
					'NAND43-P1'  =>	'2.496',								
					'NAND43-P2'  =>	'2.496',		
					'NAND43-P3'  =>	'2.496',
					'NAND43-P4'  =>	'0.52',					
					'NAND44-N1'  =>	'0.26',						
					'NAND44-N2'  =>	'0.26',						
					'NAND44-N3'  =>	'0.26',						
					'NAND44-N4'  =>	'0.26',						
					'NAND44-P1'  =>	'2.496',
					'NAND44-P2'  =>	'2.496',
					'NAND44-P3'  =>	'2.496',
					'NAND44-P4'  =>	'2.496',
					'NAND45-N1'  =>	'2.652',					
					'NAND45-N2'  =>	'2.652',
					'NAND45-N3'  =>	'2.652',
					'NAND45-N4'  =>	'2.652',
					'NAND45-P1'  =>	'0.52',										
					'NAND45-P2'  =>	'0.52',		
					'NAND45-P3'  =>	'0.52',
					'NAND45-P4'  =>	'0.52',					
					'NAND46-N1'  =>	'2.652',
					'NAND46-N2'  =>	'2.652',
					'NAND46-N3'  =>	'2.652',
					'NAND46-N4'  =>	'2.652',
					'NAND46-P1'  =>	'2.496',								
					'NAND46-P2'  =>	'0.52',		
					'NAND46-P3'  =>	'0.52',
					'NAND46-P4'  =>	'0.52',					
					'NAND47-N1'  =>	'2.652',
					'NAND47-N2'  =>	'2.652',
					'NAND47-N3'  =>	'2.652',
					'NAND47-N4'  =>	'2.652',
					'NAND47-P1'  =>	'2.496',								
					'NAND47-P2'  =>	'2.496',
					'NAND47-P3'  =>	'0.52',
					'NAND47-P4'  =>	'0.52',					
					'NAND48-N1'  =>	'2.652',
					'NAND48-N2'  =>	'2.652',
					'NAND48-N3'  =>	'2.652',
					'NAND48-N4'  =>	'2.652',
					'NAND48-P1'  =>	'2.496',								
					'NAND48-P2'  =>	'2.496',								
					'NAND48-P3'  =>	'2.496',								
					'NAND48-P4'  =>	'0.52',	
					'NAND420-N1'  =>	'2.652',
					'NAND420-N2'  =>	'2.652',
					'NAND420-N3'  =>	'2.652',
					'NAND420-N4'  =>	'2.652',
					'NAND420-P1'  =>	'2.496',
					'NAND420-P2'  =>	'2.496'	,			
					'NAND420-P3'  =>	'2.496'	,								
					'NAND420-P4'  =>	'2.496',					
					'NOR21-N1'  =>	'1.04',						
					'NOR21-N2'  =>	'0.26',						
					'NOR21-P1'  =>	'0.52',										
					'NOR21-P2'  =>	'0.52',
					'NOR22-N1'  =>	'1.04',						
					'NOR22-N2'  =>	'1.04',						
					'NOR22-P1'  =>	'0.52',										
					'NOR22-P2'  =>	'0.52',	
					'NOR23-N1'  =>	'0.26',						
					'NOR23-N2'  =>	'0.26',						
					'NOR23-P1'  =>	'4.576',									
					'NOR23-P2'  =>	'4.576',
					'NOR24-N1'  =>	'1.04',						
					'NOR24-N2'  =>	'0.26',						
					'NOR24-P1'  =>	'4.576',									
					'NOR24-P2'  =>	'4.576',	
					'NOR220-N1'  =>	'1.04',						
					'NOR220-N2'  =>	'1.04',						
					'NOR220-P1'  =>	'4.576',									
					'NOR220-P2'  =>	'4.576',						
					'NOR31-N1'  =>	'1.04',						
					'NOR31-N2'  =>	'0.26',						
					'NOR31-N3'  =>	'0.26',						
					'NOR31-P1'  =>	'0.52',										
					'NOR31-P2'  =>	'0.52',		
					'NOR31-P3'  =>	'0.52',
					'NOR32-N1'  =>	'1.04',						
					'NOR32-N2'  =>	'1.04',						
					'NOR32-N3'  =>	'0.26',						
					'NOR32-P1'  =>	'0.52',										
					'NOR32-P2'  =>	'0.52',		
					'NOR32-P3'  =>	'0.52',					
					'NOR33-N1'  =>	'1.04',						
					'NOR33-N2'  =>	'1.04',						
					'NOR33-N3'  =>	'1.04',						
					'NOR33-P1'  =>	'0.52',										
					'NOR33-P2'  =>	'0.52',		
					'NOR33-P3'  =>	'0.52',					
					'NOR34-N1'  =>	'0.26',						
					'NOR34-N2'  =>	'0.26',						
					'NOR34-N3'  =>	'0.26',						
					'NOR34-P1'  =>	'6.448',									
					'NOR34-P2'  =>	'6.448',
					'NOR34-P3'  =>	'6.448',
					'NOR35-N1'  =>	'1.04',						
					'NOR35-N2'  =>	'0.26',						
					'NOR35-N3'  =>	'0.26',						
					'NOR35-P1'  =>	'6.448',
					'NOR35-P2'  =>	'6.448',
					'NOR35-P3'  =>	'6.448',
					'NOR36-N1'  =>	'1.04',						
					'NOR36-N2'  =>	'1.04',						
					'NOR36-N3'  =>	'0.26',						
					'NOR36-P1'  =>	'6.448',
					'NOR36-P2'  =>	'6.448',
					'NOR36-P3'  =>	'6.448',
					'NOR320-N1'  =>	'1.04',							
					'NOR320-N2'  =>	'1.04',							
					'NOR320-N3'  =>	'1.04',							
					'NOR320-P1'  =>	'6.448',									
					'NOR320-P2'  =>	'6.448',	
					'NOR320-P3'  =>	'6.448',					
					'NOR41-N1'  =>	'1.04',						
					'NOR41-N2'  =>	'0.26',						
					'NOR41-N3'  =>	'0.26',						
					'NOR41-N4'  =>	'0.26',						
					'NOR41-P1'  =>	'0.52',										
					'NOR41-P2'  =>	'0.52',		
					'NOR41-P3'  =>	'0.52',
					'NOR41-P4'  =>	'0.52',					
					'NOR42-N1'  =>	'1.04',						
					'NOR42-N2'  =>	'1.04',						
					'NOR42-N3'  =>	'0.26',						
					'NOR42-N4'  =>	'0.26',						
					'NOR42-P1'  =>	'0.52',										
					'NOR42-P2'  =>	'0.52',		
					'NOR42-P3'  =>	'0.52',
					'NOR42-P4'  =>	'0.52',											
					'NOR43-N1'  =>	'1.04',						
					'NOR43-N2'  =>	'1.04',						
					'NOR43-N3'  =>	'1.04',						
					'NOR43-N4'  =>	'0.26',						
					'NOR43-P1'  =>	'0.52',										
					'NOR43-P2'  =>	'0.52',		
					'NOR43-P3'  =>	'0.52',
					'NOR43-P4'  =>	'0.52',					
					'NOR44-N1'  =>	'1.04',						
					'NOR44-N2'  =>	'1.04',						
					'NOR44-N3'  =>	'1.04',						
					'NOR44-N4'  =>	'1.04',						
					'NOR44-P1'  =>	'0.52',										
					'NOR44-P2'  =>	'0.52',		
					'NOR44-P3'  =>	'0.52',
					'NOR44-P4'  =>	'0.52',					
					'NOR45-N1'  =>	'0.26',						
					'NOR45-N2'  =>	'0.26',						
					'NOR45-N3'  =>	'0.26',						
					'NOR45-N4'  =>	'0.26',						
					'NOR45-P1'  =>	'7.8',										
					'NOR45-P2'  =>	'7.8',										
					'NOR45-P3'  =>	'7.8',										
					'NOR45-P4'  =>	'7.8',										
					'NOR46-N1'  =>	'1.04',						
					'NOR46-N2'  =>	'0.26',						
					'NOR46-N3'  =>	'0.26',						
					'NOR46-N4'  =>	'0.26',						
					'NOR46-P1'  =>	'7.8',										
					'NOR46-P2'  =>	'7.8',		
					'NOR46-P3'  =>	'7.8',
					'NOR46-P4'  =>	'7.8',					
					'NOR47-N1'  =>	'1.04',							
					'NOR47-N2'  =>	'1.04',							
					'NOR47-N3'  =>	'0.26',						
					'NOR47-N4'  =>	'0.26',						
					'NOR47-P1'  =>	'7.8',											
					'NOR47-P2'  =>	'7.8',			
					'NOR47-P3'  =>	'7.8',
					'NOR47-P4'  =>	'7.8',						
					'NOR48-N1'  =>	'1.04',							
					'NOR48-N2'  =>	'1.04',							
					'NOR48-N3'  =>	'1.04',							
					'NOR48-N4'  =>	'0.26',						
					'NOR48-P1'  =>	'7.8',											
					'NOR48-P2'  =>	'7.8',			
					'NOR48-P3'  =>	'7.8',
					'NOR48-P4'  =>	'7.8',										
					'NOR420-N1'  =>	'1.04',							
					'NOR420-N2'  =>	'1.04',							
					'NOR420-N3'  =>	'1.04',							
					'NOR420-N4'  =>	'1.04',							
					'NOR420-P1'  =>	'7.8',											
					'NOR420-P2'  =>	'7.8',			
					'NOR420-P3'  =>	'7.8',
					'NOR420-P4'  =>	'7.8',										
			);
}	

				
{
%transArea_45nm = (		'NOT11-N1'	=>	'0.09', 
					'NOT11-P1'	=>	'0.9',				
					'NOT12-N1'	=>	'0.504', 
					'NOT12-P1'	=>	'0.18',						
					'NOT120-N1'	=>	'0.504',						
					'NOT120-P1'	=>	'0.9',						
					'NAND21-N1'  =>	'0.09',						
					'NAND21-N2'  =>	'0.09',						
					'NAND21-P1'  =>	'0.9',										
					'NAND21-P2'  =>	'0.18',	
					'NAND22-N1'  =>	'0.09',						
					'NAND22-N2'  =>	'0.09',						
					'NAND22-P1'  =>	'0.9',										
					'NAND22-P2'  =>	'0.9',
					'NAND23-N1'  =>	'0.828',						
					'NAND23-N2'  =>	'0.828',						
					'NAND23-P1'  =>	'0.18',										
					'NAND23-P2'  =>	'0.18',	
					'NAND24-N1'  =>	'0.81',						
					'NAND24-N2'  =>	'0.81',						
					'NAND24-P1'  =>	'0.9',										
					'NAND24-P2'  =>	'0.18',	
					'NAND220-N1'  =>	'0.81',
					'NAND220-N2'  =>	'0.81',
					'NAND220-P1'  =>	'0.9',
					'NAND220-P2'  =>	'0.9',										
					'NAND31-N1'  =>	'0.09',						
					'NAND31-N2'  =>	'0.09',						
					'NAND31-N3'  =>	'0.09',						
					'NAND31-P1'  =>	'0.9',										
					'NAND31-P2'  =>	'0.18',		
					'NAND31-P3'  =>	'0.18',
					'NAND32-N1'  =>	'0.09',						
					'NAND32-N2'  =>	'0.09',						
					'NAND32-N3'  =>	'0.09',						
					'NAND32-P1'  =>	'0.9',										
					'NAND32-P2'  =>	'0.9',		
					'NAND32-P3'  =>	'0.18',						
					'NAND33-N1'  =>	'0.09',						
					'NAND33-N2'  =>	'0.09',						
					'NAND33-N3'  =>	'0.09',						
					'NAND33-P1'  =>	'0.9',										
					'NAND33-P2'  =>	'0.9',		
					'NAND33-P3'  =>	'0.9',					
					'NAND34-N1'  =>	'1.116',						
					'NAND34-N2'  =>	'1.116',						
					'NAND34-N3'  =>	'1.116',						
					'NAND34-P1'  =>	'0.18',										
					'NAND34-P2'  =>	'0.18',		
					'NAND34-P3'  =>	'0.18',					
					'NAND35-N1'  =>	'1.116',						
					'NAND35-N2'  =>	'1.116',						
					'NAND35-N3'  =>	'1.116',						
					'NAND35-P1'  =>	'0.9',										
					'NAND35-P2'  =>	'0.18',		
					'NAND35-P3'  =>	'0.18',					
					'NAND36-N1'  =>	'1.08',						
					'NAND36-N2'  =>	'1.08',						
					'NAND36-N3'  =>	'1.08',						
					'NAND36-P1'  =>	'0.9',										
					'NAND36-P2'  =>	'0.9',		
					'NAND36-P3'  =>	'0.18',	
					'NAND320-N1'  =>	'1.08',
					'NAND320-N2'  =>	'1.08',
					'NAND320-N3'  =>	'1.08',
					'NAND320-P1'  =>	'0.9',
					'NAND320-P2'  =>	'0.9',					
					'NAND320-P3'  =>	'0.9',					
					'NAND41-N1'  =>	'0.09',						
					'NAND41-N2'  =>	'0.09',						
					'NAND41-N3'  =>	'0.09',						
					'NAND41-N4'  =>	'0.09',						
					'NAND41-P1'  =>	'0.9',										
					'NAND41-P2'  =>	'0.18',		
					'NAND41-P3'  =>	'0.18',
					'NAND41-P4'  =>	'0.18',					
					'NAND42-N1'  =>	'0.09',						
					'NAND42-N2'  =>	'0.09',						
					'NAND42-N3'  =>	'0.09',						
					'NAND42-N4'  =>	'0.09',						
					'NAND42-P1'  =>	'0.9',										
					'NAND42-P2'  =>	'0.9',		
					'NAND42-P3'  =>	'0.18',
					'NAND42-P4'  =>	'0.18',					
					'NAND43-N1'  =>	'0.09',						
					'NAND43-N2'  =>	'0.09',						
					'NAND43-N3'  =>	'0.09',						
					'NAND43-N4'  =>	'0.09',						
					'NAND43-P1'  =>	'0.9',										
					'NAND43-P2'  =>	'0.9',		
					'NAND43-P3'  =>	'0.9',
					'NAND43-P4'  =>	'0.18',					
					'NAND44-N1'  =>	'0.09',						
					'NAND44-N2'  =>	'0.09',						
					'NAND44-N3'  =>	'0.09',						
					'NAND44-N4'  =>	'0.09',						
					'NAND44-P1'  =>	'0.9',										
					'NAND44-P2'  =>	'0.9',		
					'NAND44-P3'  =>	'0.9',
					'NAND44-P4'  =>	'0.9',					
					'NAND45-N1'  =>	'1.35',						
					'NAND45-N2'  =>	'1.35',						
					'NAND45-N3'  =>	'1.35',						
					'NAND45-N4'  =>	'1.35',						
					'NAND45-P1'  =>	'0.18',										
					'NAND45-P2'  =>	'0.18',		
					'NAND45-P3'  =>	'0.18',
					'NAND45-P4'  =>	'0.18',					
					'NAND46-N1'  =>	'1.35',						
					'NAND46-N2'  =>	'1.35',						
					'NAND46-N3'  =>	'1.35',						
					'NAND46-N4'  =>	'1.35',						
					'NAND46-P1'  =>	'0.9',										
					'NAND46-P2'  =>	'0.18',		
					'NAND46-P3'  =>	'0.18',
					'NAND46-P4'  =>	'0.18',					
					'NAND47-N1'  =>	'1.35',						
					'NAND47-N2'  =>	'1.35',						
					'NAND47-N3'  =>	'1.35',						
					'NAND47-N4'  =>	'1.35',						
					'NAND47-P1'  =>	'0.9',										
					'NAND47-P2'  =>	'0.9',		
					'NAND47-P3'  =>	'0.18',
					'NAND47-P4'  =>	'0.18',					
					'NAND48-N1'  =>	'1.269',			
					'NAND48-N2'  =>	'1.269',						
					'NAND48-N3'  =>	'1.269',						
					'NAND48-N4'  =>	'1.269',						
					'NAND48-P1'  =>	'0.9',										
					'NAND48-P2'  =>	'0.9',		
					'NAND48-P3'  =>	'0.9',
					'NAND48-P4'  =>	'0.18',	
					'NAND420-N1'  =>	'1.269',
					'NAND420-N2'  =>	'1.269',
					'NAND420-N3'  =>	'1.269',
					'NAND420-N4'  =>	'1.269',
					'NAND420-P1'  =>	'0.9',
					'NAND420-P2'  =>	'0.9',					
					'NAND420-P3'  =>	'0.9',										
					'NAND420-P4'  =>	'0.9',										
					'NOR21-N1'  =>	'0.504',						
					'NOR21-N2'  =>	'0.09',						
					'NOR21-P1'  =>	'0.18',										
					'NOR21-P2'  =>	'0.18',
					'NOR22-N1'  =>	'0.504',						
					'NOR22-N2'  =>	'0.504',						
					'NOR22-P1'  =>	'0.18',										
					'NOR22-P2'  =>	'0.18',	
					'NOR23-N1'  =>	'0.09',						
					'NOR23-N2'  =>	'0.09',						
					'NOR23-P1'  =>	'2.16',										
					'NOR23-P2'  =>	'2.16',	
					'NOR24-N1'  =>	'0.504',						
					'NOR24-N2'  =>	'0.09',						
					'NOR24-P1'  =>	'2.16',										
					'NOR24-P2'  =>	'2.16',		
					'NOR220-N1'  =>	'0.504',						
					'NOR220-N2'  =>	'0.504',						
					'NOR220-P1'  =>	'2.16',										
					'NOR220-P2'  =>	'2.16',							
					'NOR31-N1'  =>	'0.504',						
					'NOR31-N2'  =>	'0.09',						
					'NOR31-N3'  =>	'0.09',						
					'NOR31-P1'  =>	'0.18',										
					'NOR31-P2'  =>	'0.18',		
					'NOR31-P3'  =>	'0.18',
					'NOR32-N1'  =>	'0.504',						
					'NOR32-N2'  =>	'0.504',						
					'NOR32-N3'  =>	'0.09',						
					'NOR32-P1'  =>	'0.18',										
					'NOR32-P2'  =>	'0.18',		
					'NOR32-P3'  =>	'0.18',					
					'NOR33-N1'  =>	'0.504',						
					'NOR33-N2'  =>	'0.504',						
					'NOR33-N3'  =>	'0.504',						
					'NOR33-P1'  =>	'0.18',										
					'NOR33-P2'  =>	'0.18',		
					'NOR33-P3'  =>	'0.18',					
					'NOR34-N1'  =>	'0.09',						
					'NOR34-N2'  =>	'0.09',						
					'NOR34-N3'  =>	'0.09',						
					'NOR34-P1'  =>	'3.06',										
					'NOR34-P2'  =>	'3.06',		
					'NOR34-P3'  =>	'3.06',					
					'NOR35-N1'  =>	'0.504',						
					'NOR35-N2'  =>	'0.09',						
					'NOR35-N3'  =>	'0.09',						
					'NOR35-P1'  =>	'3.06',										
					'NOR35-P2'  =>	'3.06',		
					'NOR35-P3'  =>	'3.06',					
					'NOR36-N1'  =>	'0.504',						
					'NOR36-N2'  =>	'0.504',						
					'NOR36-N3'  =>	'0.09',						
					'NOR36-P1'  =>	'3.06',										
					'NOR36-P2'  =>	'3.06',		
					'NOR36-P3'  =>	'3.06',					
					'NOR320-N1'  =>	'0.504',						
					'NOR320-N2'  =>	'0.504',						
					'NOR320-N3'  =>	'0.504',						
					'NOR320-P1'  =>	'3.06',										
					'NOR320-P2'  =>	'3.06',		
					'NOR320-P3'  =>	'3.06',						
					'NOR41-N1'  =>	'0.504',						
					'NOR41-N2'  =>	'0.09',						
					'NOR41-N3'  =>	'0.09',						
					'NOR41-N4'  =>	'0.09',						
					'NOR41-P1'  =>	'0.18',										
					'NOR41-P2'  =>	'0.18',		
					'NOR41-P3'  =>	'0.18',
					'NOR41-P4'  =>	'0.18',					
					'NOR42-N1'  =>	'0.504',						
					'NOR42-N2'  =>	'0.504',						
					'NOR42-N3'  =>	'0.09',						
					'NOR42-N4'  =>	'0.09',						
					'NOR42-P1'  =>	'0.18',										
					'NOR42-P2'  =>	'0.18',		
					'NOR42-P3'  =>	'0.18',
					'NOR42-P4'  =>	'0.18',											
					'NOR43-N1'  =>	'0.504',						
					'NOR43-N2'  =>	'0.504',						
					'NOR43-N3'  =>	'0.504',						
					'NOR43-N4'  =>	'0.09',						
					'NOR43-P1'  =>	'0.18',										
					'NOR43-P2'  =>	'0.18',		
					'NOR43-P3'  =>	'0.18',
					'NOR43-P4'  =>	'0.18',					
					'NOR44-N1'  =>	'0.504',						
					'NOR44-N2'  =>	'0.504',						
					'NOR44-N3'  =>	'0.504',						
					'NOR44-N4'  =>	'0.504',						
					'NOR44-P1'  =>	'0.18',										
					'NOR44-P2'  =>	'0.18',		
					'NOR44-P3'  =>	'0.18',
					'NOR44-P4'  =>	'0.18',					
					'NOR45-N1'  =>	'0.09',						
					'NOR45-N2'  =>	'0.09',						
					'NOR45-N3'  =>	'0.09',						
					'NOR45-N4'  =>	'0.09',						
					'NOR45-P1'  =>	'4.104',										
					'NOR45-P2'  =>	'4.104',		
					'NOR45-P3'  =>	'4.104',
					'NOR45-P4'  =>	'4.104',					
					'NOR46-N1'  =>	'0.504',						
					'NOR46-N2'  =>	'0.09',						
					'NOR46-N3'  =>	'0.09',						
					'NOR46-N4'  =>	'0.09',						
					'NOR46-P1'  =>	'4.104',										
					'NOR46-P2'  =>	'4.104',		
					'NOR46-P3'  =>	'4.104',
					'NOR46-P4'  =>	'4.104',					
					'NOR47-N1'  =>	'0.504',						
					'NOR47-N2'  =>	'0.504',						
					'NOR47-N3'  =>	'0.09',						
					'NOR47-N4'  =>	'0.09',						
					'NOR47-P1'  =>	'4.104',										
					'NOR47-P2'  =>	'4.104',		
					'NOR47-P3'  =>	'4.104',
					'NOR47-P4'  =>	'4.104',					
					'NOR48-N1'  =>	'0.504',						
					'NOR48-N2'  =>	'0.504',						
					'NOR48-N3'  =>	'0.504',						
					'NOR48-N4'  =>	'0.09',						
					'NOR48-P1'  =>	'4.104',										
					'NOR48-P2'  =>	'4.104',		
					'NOR48-P3'  =>	'4.104',
					'NOR48-P4'  =>	'4.104',									
					'NOR420-N1'  =>	'0.504',						
					'NOR420-N2'  =>	'0.504',						
					'NOR420-N3'  =>	'0.504',						
					'NOR420-N4'  =>	'0.504',						
					'NOR420-P1'  =>	'4.104',										
					'NOR420-P2'  =>	'4.104',		
					'NOR420-P3'  =>	'4.104',
					'NOR420-P4'  =>	'4.104',									
			);
}	


{
%transArea_Zhou_130nm = ('NOT11-N1'	=>	'0.26', 
					'NOT11-P1'	=>	'2.496',		
					'NOT12-N1'	=>	'1.040', 
					'NOT12-P1'	=>	'0.520',					
					'NOT120-N1'	=>	'1.248',						
					'NOT120-P1'	=>	'2.496',					
					'NAND21-N1'  =>	'0.26',						
					'NAND21-N2'  =>	'0.26',						
					'NAND21-P1'  =>	'2.496',								
					'NAND21-P2'  =>	'0.52',	
					'NAND22-N1'  =>	'0.26',						
					'NAND22-N2'  =>	'0.26',						
					'NAND22-P1'  =>	'2.496',								
					'NAND22-P2'  =>	'2.496',
					'NAND23-N1'  =>	'1.612',						
					'NAND23-N2'  =>	'1.612',						
					'NAND23-P1'  =>	'0.52',										
					'NAND23-P2'  =>	'0.52',	
					'NAND24-N1'  =>	'1.612',					
					'NAND24-N2'  =>	'1.612',					
					'NAND24-P1'  =>	'2.496',								
					'NAND24-P2'  =>	'0.52',	
					'NAND220-N1'  =>	'1.612',
					'NAND220-N2'  =>	'1.612',
					'NAND220-P1'  =>	'3.224',
					'NAND220-P2'  =>	'3.224',					
					'NAND31-N1'  =>	'0.26',						
					'NAND31-N2'  =>	'0.26',						
					'NAND31-N3'  =>	'0.26',						
					'NAND31-P1'  =>	'2.496',								
					'NAND31-P2'  =>	'0.52',		
					'NAND31-P3'  =>	'0.52',
					'NAND32-N1'  =>	'0.26',						
					'NAND32-N2'  =>	'0.26',						
					'NAND32-N3'  =>	'0.26',						
					'NAND32-P1'  =>	'2.496',								
					'NAND32-P2'  =>	'2.496',
					'NAND32-P3'  =>	'0.52',						
					'NAND33-N1'  =>	'0.26',						
					'NAND33-N2'  =>	'0.26',						
					'NAND33-N3'  =>	'0.26',						
					'NAND33-P1'  =>	'2.496',								
					'NAND33-P2'  =>	'2.496',
					'NAND33-P3'  =>	'2.496',
					'NAND34-N1'  =>	'2.131',						
					'NAND34-N2'  =>	'2.132',						
					'NAND34-N3'  =>	'2.132',						
					'NAND34-P1'  =>	'0.52',										
					'NAND34-P2'  =>	'0.52',		
					'NAND34-P3'  =>	'0.52',				
					'NAND35-N1'  =>	'2.132',						
					'NAND35-N2'  =>	'2.132',						
					'NAND35-N3'  =>	'2.132',						
					'NAND35-P1'  =>	'2.496',								
					'NAND35-P2'  =>	'0.52',	
					'NAND35-P3'  =>	'0.52',				
					'NAND36-N1'  =>	'2.132',					
					'NAND36-N2'  =>	'2.132',					
					'NAND36-N3'  =>	'2.132',					
					'NAND36-P1'  =>	'2.496',								
					'NAND36-P2'  =>	'2.496',
					'NAND36-P3'  =>	'0.52',	
					'NAND320-N1'  =>	'2.132',
					'NAND320-N2'  =>	'2.132',
					'NAND320-N3'  =>	'2.132',
					'NAND320-P1'  =>	'4.264',
					'NAND320-P2'  =>	'4.264',
					'NAND320-P3'  =>	'4.264',					
					'NAND41-N1'  =>	'0.26',						
					'NAND41-N2'  =>	'0.26',						
					'NAND41-N3'  =>	'0.26',						
					'NAND41-N4'  =>	'0.26',						
					'NAND41-P1'  =>	'2.496',								
					'NAND41-P2'  =>	'0.52',		
					'NAND41-P3'  =>	'0.52',
					'NAND41-P4'  =>	'0.52',					
					'NAND42-N1'  =>	'0.26',						
					'NAND42-N2'  =>	'0.26',						
					'NAND42-N3'  =>	'0.26',						
					'NAND42-N4'  =>	'0.26',						
					'NAND42-P1'  =>	'2.496',								
					'NAND42-P2'  =>	'2.496',
					'NAND42-P3'  =>	'0.52',
					'NAND42-P4'  =>	'0.52',					
					'NAND43-N1'  =>	'0.26',						
					'NAND43-N2'  =>	'0.26',						
					'NAND43-N3'  =>	'0.26',						
					'NAND43-N4'  =>	'0.26',						
					'NAND43-P1'  =>	'2.496',								
					'NAND43-P2'  =>	'2.496',		
					'NAND43-P3'  =>	'2.496',
					'NAND43-P4'  =>	'0.52',					
					'NAND44-N1'  =>	'0.26',						
					'NAND44-N2'  =>	'0.26',						
					'NAND44-N3'  =>	'0.26',						
					'NAND44-N4'  =>	'0.26',						
					'NAND44-P1'  =>	'2.496',
					'NAND44-P2'  =>	'2.496',
					'NAND44-P3'  =>	'2.496',
					'NAND44-P4'  =>	'2.496',
					'NAND45-N1'  =>	'2.652',					
					'NAND45-N2'  =>	'2.652',
					'NAND45-N3'  =>	'2.652',
					'NAND45-N4'  =>	'2.652',
					'NAND45-P1'  =>	'0.52',										
					'NAND45-P2'  =>	'0.52',		
					'NAND45-P3'  =>	'0.52',
					'NAND45-P4'  =>	'0.52',					
					'NAND46-N1'  =>	'2.652',
					'NAND46-N2'  =>	'2.652',
					'NAND46-N3'  =>	'2.652',
					'NAND46-N4'  =>	'2.652',
					'NAND46-P1'  =>	'2.496',								
					'NAND46-P2'  =>	'0.52',		
					'NAND46-P3'  =>	'0.52',
					'NAND46-P4'  =>	'0.52',					
					'NAND47-N1'  =>	'2.652',
					'NAND47-N2'  =>	'2.652',
					'NAND47-N3'  =>	'2.652',
					'NAND47-N4'  =>	'2.652',
					'NAND47-P1'  =>	'2.496',								
					'NAND47-P2'  =>	'2.496',
					'NAND47-P3'  =>	'0.52',
					'NAND47-P4'  =>	'0.52',					
					'NAND48-N1'  =>	'2.652',
					'NAND48-N2'  =>	'2.652',
					'NAND48-N3'  =>	'2.652',
					'NAND48-N4'  =>	'2.652',
					'NAND48-P1'  =>	'2.496',								
					'NAND48-P2'  =>	'2.496',								
					'NAND48-P3'  =>	'2.496',								
					'NAND48-P4'  =>	'0.52',	
					'NAND420-N1'  =>	'2.652',
					'NAND420-N2'  =>	'2.652',
					'NAND420-N3'  =>	'2.652',
					'NAND420-N4'  =>	'2.652',
					'NAND420-P1'  =>	'5.304',
					'NAND420-P2'  =>	'5.304',
					'NAND420-P3'  =>	'5.304',
					'NAND420-P4'  =>	'5.304',
					'NOR21-N1'  =>	'1.04',						
					'NOR21-N2'  =>	'0.26',						
					'NOR21-P1'  =>	'0.52',										
					'NOR21-P2'  =>	'0.52',
					'NOR22-N1'  =>	'1.04',						
					'NOR22-N2'  =>	'1.04',						
					'NOR22-P1'  =>	'0.52',										
					'NOR22-P2'  =>	'0.52',	
					'NOR23-N1'  =>	'0.26',						
					'NOR23-N2'  =>	'0.26',						
					'NOR23-P1'  =>	'4.576',									
					'NOR23-P2'  =>	'4.576',
					'NOR24-N1'  =>	'1.04',						
					'NOR24-N2'  =>	'0.26',						
					'NOR24-P1'  =>	'4.576',									
					'NOR24-P2'  =>	'4.576',	
					'NOR220-N1'  =>	'2.288',					
					'NOR220-N2'  =>	'2.288',		
					'NOR220-P1'  =>	'4.576',									
					'NOR220-P2'  =>	'4.576',						
					'NOR31-N1'  =>	'1.04',						
					'NOR31-N2'  =>	'0.26',						
					'NOR31-N3'  =>	'0.26',						
					'NOR31-P1'  =>	'0.52',										
					'NOR31-P2'  =>	'0.52',		
					'NOR31-P3'  =>	'0.52',
					'NOR32-N1'  =>	'1.04',						
					'NOR32-N2'  =>	'1.04',						
					'NOR32-N3'  =>	'0.26',						
					'NOR32-P1'  =>	'0.52',										
					'NOR32-P2'  =>	'0.52',		
					'NOR32-P3'  =>	'0.52',					
					'NOR33-N1'  =>	'1.04',						
					'NOR33-N2'  =>	'1.04',						
					'NOR33-N3'  =>	'1.04',						
					'NOR33-P1'  =>	'0.52',										
					'NOR33-P2'  =>	'0.52',		
					'NOR33-P3'  =>	'0.52',					
					'NOR34-N1'  =>	'0.26',						
					'NOR34-N2'  =>	'0.26',						
					'NOR34-N3'  =>	'0.26',						
					'NOR34-P1'  =>	'6.448',									
					'NOR34-P2'  =>	'6.448',
					'NOR34-P3'  =>	'6.448',
					'NOR35-N1'  =>	'1.04',						
					'NOR35-N2'  =>	'0.26',						
					'NOR35-N3'  =>	'0.26',						
					'NOR35-P1'  =>	'6.448',
					'NOR35-P2'  =>	'6.448',
					'NOR35-P3'  =>	'6.448',
					'NOR36-N1'  =>	'1.04',						
					'NOR36-N2'  =>	'1.04',						
					'NOR36-N3'  =>	'0.26',						
					'NOR36-P1'  =>	'6.448',
					'NOR36-P2'  =>	'6.448',
					'NOR36-P3'  =>	'6.448',
					'NOR320-N1'  =>	'3.224',						
					'NOR320-N2'  =>	'3.224',
					'NOR320-N3'  =>	'3.224',
					'NOR320-P1'  =>	'6.448',									
					'NOR320-P2'  =>	'6.448',	
					'NOR320-P3'  =>	'6.448',					
					'NOR41-N1'  =>	'1.04',						
					'NOR41-N2'  =>	'0.26',						
					'NOR41-N3'  =>	'0.26',						
					'NOR41-N4'  =>	'0.26',						
					'NOR41-P1'  =>	'0.52',										
					'NOR41-P2'  =>	'0.52',		
					'NOR41-P3'  =>	'0.52',
					'NOR41-P4'  =>	'0.52',					
					'NOR42-N1'  =>	'1.04',						
					'NOR42-N2'  =>	'1.04',						
					'NOR42-N3'  =>	'0.26',						
					'NOR42-N4'  =>	'0.26',						
					'NOR42-P1'  =>	'0.52',										
					'NOR42-P2'  =>	'0.52',		
					'NOR42-P3'  =>	'0.52',
					'NOR42-P4'  =>	'0.52',											
					'NOR43-N1'  =>	'1.04',						
					'NOR43-N2'  =>	'1.04',						
					'NOR43-N3'  =>	'1.04',						
					'NOR43-N4'  =>	'0.26',						
					'NOR43-P1'  =>	'0.52',										
					'NOR43-P2'  =>	'0.52',		
					'NOR43-P3'  =>	'0.52',
					'NOR43-P4'  =>	'0.52',					
					'NOR44-N1'  =>	'1.04',						
					'NOR44-N2'  =>	'1.04',						
					'NOR44-N3'  =>	'1.04',						
					'NOR44-N4'  =>	'1.04',						
					'NOR44-P1'  =>	'0.52',										
					'NOR44-P2'  =>	'0.52',		
					'NOR44-P3'  =>	'0.52',
					'NOR44-P4'  =>	'0.52',					
					'NOR45-N1'  =>	'0.26',						
					'NOR45-N2'  =>	'0.26',						
					'NOR45-N3'  =>	'0.26',						
					'NOR45-N4'  =>	'0.26',						
					'NOR45-P1'  =>	'7.8',										
					'NOR45-P2'  =>	'7.8',										
					'NOR45-P3'  =>	'7.8',										
					'NOR45-P4'  =>	'7.8',										
					'NOR46-N1'  =>	'1.04',						
					'NOR46-N2'  =>	'0.26',						
					'NOR46-N3'  =>	'0.26',						
					'NOR46-N4'  =>	'0.26',						
					'NOR46-P1'  =>	'7.8',										
					'NOR46-P2'  =>	'7.8',		
					'NOR46-P3'  =>	'7.8',
					'NOR46-P4'  =>	'7.8',					
					'NOR47-N1'  =>	'1.04',							
					'NOR47-N2'  =>	'1.04',							
					'NOR47-N3'  =>	'0.26',						
					'NOR47-N4'  =>	'0.26',						
					'NOR47-P1'  =>	'7.8',											
					'NOR47-P2'  =>	'7.8',			
					'NOR47-P3'  =>	'7.8',
					'NOR47-P4'  =>	'7.8',						
					'NOR48-N1'  =>	'1.04',							
					'NOR48-N2'  =>	'1.04',							
					'NOR48-N3'  =>	'1.04',							
					'NOR48-N4'  =>	'0.26',						
					'NOR48-P1'  =>	'7.8',											
					'NOR48-P2'  =>	'7.8',			
					'NOR48-P3'  =>	'7.8',
					'NOR48-P4'  =>	'7.8',										
					'NOR420-N1'  =>	'3.90',							
					'NOR420-N2'  =>	'3.90',		
					'NOR420-N3'  =>	'3.90',
					'NOR420-N4'  =>	'3.90',
					'NOR420-P1'  =>	'7.8',											
					'NOR420-P2'  =>	'7.8',			
					'NOR420-P3'  =>	'7.8',
					'NOR420-P4'  =>	'7.8',										
			);
}	


$flag = 0;


# $inputFile = fileparse($inputFile, ".fault");
#print "Input file = $inputFile \n";
#print "inputFile = $inputFile \n"; 
#$outputFile_O = $inputFile."-stats.txt";

$benchFile = "$cwd/$inputFile.bench";
print "\n\tReading Bench File $benchFile \n\n";

my $start_time = [Time::HiRes::gettimeofday()];
#-----------------------------------------------------
readBenchFile();
# readFaultsFile();
# findEquivFaults();
 # exit;

$numberOfPrimaryInputs = scalar @primaryInputs;
if ($numberOfPrimaryInputs > 20) {
	$numberOfTestVectors = 100000;	
}

else {	
	$numberOfTestVectors = 2**$numberOfPrimaryInputs;	
	# $numberOfTestVectors = 100000;
}

#####################################################
# Retrieve the sa0 and sa1 probabilities of gate
%circuitFaults_0 = %{retrieve($inputFile."_sa0.prob")};
%circuitFaults_1 = %{retrieve($inputFile."_sa1.prob")};

$sum = 0;
@inter_IO_Gates = nsort @inter_IO_Gates;

foreach $gate (nsort keys %circuitFaults_0) {	
	if ( (grep {$_ eq $gate} @primaryInputs) or $gate =~ m/>/ ) {
		next;
	}
	else {	
		$s = $circuitFaults_0{$gate}/$numberOfTestVectors + $circuitFaults_1{$gate}/$numberOfTestVectors;
		# print "$gate: sa0 = ",$circuitFaults_0{$gate}/$numberOfTestVectors,", sa1 = ",$circuitFaults_1{$gate}/$numberOfTestVectors,", S = $s\n";
		$sum += $s;
	}
}
print "\n$inputFile: SUM: $sum, Gates: ", scalar @inter_IO_Gates,"\n";


selectionAlgorithmWithPOFSUpdate_ONLY($threshold);
# selectionAlgorithmWithPOFSUpdate_AREACONSTRAINT($threshold);

# selectionAlgorithm_SymmetricScaling_ZhouPaper($threshold);
# Lazzari_PAPER($threshold);

print "Number of test vectors: $numberOfTestVectors\n";
print "MORE THAN 4 INPUTS: @moreThan4Inputs\n";


