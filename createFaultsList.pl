#########################################################################################
# Description: 	This file generates fault statistics from the faults					#
#			   	file generated by HOPE for a given benchmark. The						#
#				output is a new bench file consisting of Quaded and Duplicated logic	#
#																						#
# USAGE: perl circuit-stats.pl [Faults File] [Error Threshold]							#
#		[Faults File] = log file generated by HOPE.										#
#		[Error Threshold] =  reports only errors >= Threshold.							#
# 																						#
# Author: Ahmad Tariq Sheikh.															#
#																						#
# Date: October 26, 2013																#
#																						#
#########################################################################################

#!/usr/bin/perl -w

use warnings;
use Cwd;
use Time::HiRes;
use File::Basename;
use Data::Dumper qw(Dumper); 
use Storable qw(retrieve nstore dclone);
use Clone qw(clone);
use Sort::Naturally;
#---------------------

sub readBenchFile {
	# print "\tReading $inputFile.bench file ... \n";
	# my $start_time = [Time::HiRes::gettimeofday()];
	
	$benchFile = "$inputFile.bench";
	print "B: $benchFile\n";
	open (INPUT_FILE, $benchFile) or die $!;
	
	$currentPO = ();
	$poIndexCounter = 0;
	my %tempCompleteGates = ();	
	%gateBelongings = (); 
	@primaryOutputs = ();
	@primaryInputs = ();
	@inter_IO_Gates = ();
	@allGates = ();
	@multiFanOuts = ();
	%poIndices = ();
	%inputs = ();
	%fanouts = ();
	%completeGates = ();
	%gatesCounter = ();

		
	while(<INPUT_FILE>) {
		if ($_ =~ m/INPUT(.*)/) {		
			if ($1 =~ m/(\w+)/) {
				push (@primaryInputs, $1);	
			}
		}
		elsif ($_ =~ m/OUTPUT(.*)/) {
			if ($1 =~ m/(\w+)/) {
				push (@primaryOutputs, $1);					
			}
		}
		elsif ($_ =~ /#/ or $_ =~ /^\s/) {
			next;
		}		
		elsif ($_ =~ m/=/) {			
			
			my @gateList = ($_ =~ m/(\w+)/g);				
			$gateName[0] = $gateList[1];			
			@gateList = ($gateList[0], @gateList[2..$#gateList]);
				
						
			# print "@gateList,  Length = ", scalar @gateList, ", GN: $gateName[0],  POINDEX: $poIndexCounter\n";			
			# $cin=getc(STDIN); exit;
			
			if (grep {$_ eq $gateList[0]} @primaryOutputs) {
				$currentPO = shift(@primaryOutputs);
				push @primaryOutputs, $currentPO;
				$poIndices{$gateList[0]} = $poIndexCounter;
			}
			else {
				$currentPO = $primaryOutputs[0];
			}
						
			$gateBelongings{$gateList[0]} = $currentPO;
			
			#---------------------------------------------------
			# Create an output to input and input to output MAP
			#---------------------------------------------------
			my $connections = ();
			for my $i (1..scalar @gateList-1) {				
				$connections .= "$gateList[$i]";	
				if ((scalar @gateList > 1) && ($i < scalar @gateList-1)) {
					$connections .= "-";
				}
				
				if (exists($fanouts{$gateList[$i]})) {				
					$temp = $fanouts{$gateList[$i]};
					$fanouts{$gateList[$i]} = $temp."-".$gateList[0];
				}
				else {
					$fanouts{$gateList[$i]} = $gateList[0];	
				}				
			}
			$inputs{$gateList[0]} = $gateName[0]."-".$connections;	

			# if ($gateName[0] eq "NOT") {
				# if (grep {$_ eq $connections} @primaryInputs) {
					# $invertedInputs = $gateList[0];
				# }
			# }			
			
			push @inter_IO_Gates, $gateList[0];				
			#-------------------------------------------------
			
			for my $i(0..scalar @gateList - 1) {			
				if (!(exists($tempCompleteGates{$gateList[$i]}))) {				
					if ($i == 0) {					
						$tempCompleteGates{$gateList[$i]} = 0;	
						$gatesCounter{$gateList[$i]} = 0;
						$completeGates{$gateList[$i]} = 0;	
					}
					else {					
						$tempCompleteGates{$gateList[$i]} = $gateList[0];	
						$gatesCounter{$gateList[$i]} = 1;
						$completeGates{$gateList[$i]} = "$gateName[0]-$gateList[0]";	
					}
				}
				else {				
					$gatesCounter{$gateList[$i]}++;										
					if ($gatesCounter{$gateList[$i]} >= 2) {							
						$tempCompleteGates{"$gateList[$i]->$gateList[0]"} = $gateList[0];
						$tempCompleteGates{"$gateList[$i]->$tempCompleteGates{$gateList[$i]}"} = $tempCompleteGates{$gateList[$i]};												
						$gatesCounter{"$gateList[$i]->$gateList[0]"} = 0;
						$gatesCounter{"$gateList[$i]->$tempCompleteGates{$gateList[$i]}"} = 0;						
						
						if ($completeGates{$gateList[$i]} eq 0) {
							$completeGates{"$gateList[$i]->$gateList[0]"} = "$gateName[0]-$gateList[0]";	
						}
						else {
							$completeGates{"$gateList[$i]->$gateList[0]"} = "$gateName[0]-$gateList[0]";						
							@previousLine = split('-', $completeGates{$gateList[$i]});							
							$completeGates{"$gateList[$i]->$previousLine[1]"} = "$previousLine[0]-$previousLine[1]";					
							$completeGates{$gateList[$i]} = 0;
						}
					}
					else {	
						$tempCompleteGates{$gateList[$i]} = $gateList[0];							
						$completeGates{$gateList[$i]} = "$gateName[0]-$gateList[0]";													
					}
				}
			}					
			$poIndexCounter++;
		}		
	}	
	close(INPUT_FILE);	
	
	
	
	####################################################
	# Fanout Counter
	####################################################
	foreach my $node (%fanouts) {	
		
		if (exists($fanouts{$node})) {		
			# print "Node = $node, Fanouts = $fanouts{$node} \n";
			@row = split("-", $fanouts{$node});
			$fanoutCounter{$node} = scalar @row;
			if ($fanoutCounter{$node} > 1) { # and ($node =~ m/g/)) {
				push @multiFanOuts, $node;
			}			
		}
	}
	
	
	# my $run_time = Time::HiRes::tv_interval($start_time);
	# print "\tTime taken Reading Bench file = $run_time sec.\n\n";	
	
	@allGates = @{ dclone(\@inter_IO_Gates) };	
	@inter_IO_Gates = nsort @inter_IO_Gates;	
}
#######################################################

sub createFaultsList {
	
	open (FAULT_LIST, ">$inputFile.fn") or die $!;
	foreach $gate (@inter_IO_Gates) {
		print FAULT_LIST "$gate /0\n";
		print FAULT_LIST "$gate /1\n";
	}
	
	close(FAULT_LIST);
	
}
#######################################################

$cwd = getcwd; #get Current Working Directory
$inputFile = $ARGV[0]; #faults file generated by HOPE

@inter_IO_Gates = ();

readBenchFile();
createFaultsList();